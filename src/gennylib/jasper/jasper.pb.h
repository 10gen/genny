// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: jasper.proto

#ifndef PROTOBUF_INCLUDED_jasper_2eproto
#define PROTOBUF_INCLUDED_jasper_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_jasper_2eproto

namespace protobuf_jasper_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[22];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_jasper_2eproto
namespace jasper {
class ArchiveOptions;
class ArchiveOptionsDefaultTypeInternal;
extern ArchiveOptionsDefaultTypeInternal _ArchiveOptions_default_instance_;
class BufferOptions;
class BufferOptionsDefaultTypeInternal;
extern BufferOptionsDefaultTypeInternal _BufferOptions_default_instance_;
class BuildOptions;
class BuildOptionsDefaultTypeInternal;
extern BuildOptionsDefaultTypeInternal _BuildOptions_default_instance_;
class BuildloggerOptions;
class BuildloggerOptionsDefaultTypeInternal;
extern BuildloggerOptionsDefaultTypeInternal _BuildloggerOptions_default_instance_;
class BuildloggerURLs;
class BuildloggerURLsDefaultTypeInternal;
extern BuildloggerURLsDefaultTypeInternal _BuildloggerURLs_default_instance_;
class CacheOptions;
class CacheOptionsDefaultTypeInternal;
extern CacheOptionsDefaultTypeInternal _CacheOptions_default_instance_;
class CreateOptions;
class CreateOptionsDefaultTypeInternal;
extern CreateOptionsDefaultTypeInternal _CreateOptions_default_instance_;
class CreateOptions_EnvironmentEntry_DoNotUse;
class CreateOptions_EnvironmentEntry_DoNotUseDefaultTypeInternal;
extern CreateOptions_EnvironmentEntry_DoNotUseDefaultTypeInternal _CreateOptions_EnvironmentEntry_DoNotUse_default_instance_;
class DownloadInfo;
class DownloadInfoDefaultTypeInternal;
extern DownloadInfoDefaultTypeInternal _DownloadInfo_default_instance_;
class Filter;
class FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class JasperProcessID;
class JasperProcessIDDefaultTypeInternal;
extern JasperProcessIDDefaultTypeInternal _JasperProcessID_default_instance_;
class LogOptions;
class LogOptionsDefaultTypeInternal;
extern LogOptionsDefaultTypeInternal _LogOptions_default_instance_;
class Logger;
class LoggerDefaultTypeInternal;
extern LoggerDefaultTypeInternal _Logger_default_instance_;
class MongoDBDownloadOptions;
class MongoDBDownloadOptionsDefaultTypeInternal;
extern MongoDBDownloadOptionsDefaultTypeInternal _MongoDBDownloadOptions_default_instance_;
class OperationOutcome;
class OperationOutcomeDefaultTypeInternal;
extern OperationOutcomeDefaultTypeInternal _OperationOutcome_default_instance_;
class OutputOptions;
class OutputOptionsDefaultTypeInternal;
extern OutputOptionsDefaultTypeInternal _OutputOptions_default_instance_;
class ProcessInfo;
class ProcessInfoDefaultTypeInternal;
extern ProcessInfoDefaultTypeInternal _ProcessInfo_default_instance_;
class ProcessTags;
class ProcessTagsDefaultTypeInternal;
extern ProcessTagsDefaultTypeInternal _ProcessTags_default_instance_;
class SignalProcess;
class SignalProcessDefaultTypeInternal;
extern SignalProcessDefaultTypeInternal _SignalProcess_default_instance_;
class SplunkOptions;
class SplunkOptionsDefaultTypeInternal;
extern SplunkOptionsDefaultTypeInternal _SplunkOptions_default_instance_;
class StatusResponse;
class StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class TagName;
class TagNameDefaultTypeInternal;
extern TagNameDefaultTypeInternal _TagName_default_instance_;
}  // namespace jasper
namespace google {
namespace protobuf {
template<> ::jasper::ArchiveOptions* Arena::CreateMaybeMessage<::jasper::ArchiveOptions>(Arena*);
template<> ::jasper::BufferOptions* Arena::CreateMaybeMessage<::jasper::BufferOptions>(Arena*);
template<> ::jasper::BuildOptions* Arena::CreateMaybeMessage<::jasper::BuildOptions>(Arena*);
template<> ::jasper::BuildloggerOptions* Arena::CreateMaybeMessage<::jasper::BuildloggerOptions>(Arena*);
template<> ::jasper::BuildloggerURLs* Arena::CreateMaybeMessage<::jasper::BuildloggerURLs>(Arena*);
template<> ::jasper::CacheOptions* Arena::CreateMaybeMessage<::jasper::CacheOptions>(Arena*);
template<> ::jasper::CreateOptions* Arena::CreateMaybeMessage<::jasper::CreateOptions>(Arena*);
template<> ::jasper::CreateOptions_EnvironmentEntry_DoNotUse* Arena::CreateMaybeMessage<::jasper::CreateOptions_EnvironmentEntry_DoNotUse>(Arena*);
template<> ::jasper::DownloadInfo* Arena::CreateMaybeMessage<::jasper::DownloadInfo>(Arena*);
template<> ::jasper::Filter* Arena::CreateMaybeMessage<::jasper::Filter>(Arena*);
template<> ::jasper::JasperProcessID* Arena::CreateMaybeMessage<::jasper::JasperProcessID>(Arena*);
template<> ::jasper::LogOptions* Arena::CreateMaybeMessage<::jasper::LogOptions>(Arena*);
template<> ::jasper::Logger* Arena::CreateMaybeMessage<::jasper::Logger>(Arena*);
template<> ::jasper::MongoDBDownloadOptions* Arena::CreateMaybeMessage<::jasper::MongoDBDownloadOptions>(Arena*);
template<> ::jasper::OperationOutcome* Arena::CreateMaybeMessage<::jasper::OperationOutcome>(Arena*);
template<> ::jasper::OutputOptions* Arena::CreateMaybeMessage<::jasper::OutputOptions>(Arena*);
template<> ::jasper::ProcessInfo* Arena::CreateMaybeMessage<::jasper::ProcessInfo>(Arena*);
template<> ::jasper::ProcessTags* Arena::CreateMaybeMessage<::jasper::ProcessTags>(Arena*);
template<> ::jasper::SignalProcess* Arena::CreateMaybeMessage<::jasper::SignalProcess>(Arena*);
template<> ::jasper::SplunkOptions* Arena::CreateMaybeMessage<::jasper::SplunkOptions>(Arena*);
template<> ::jasper::StatusResponse* Arena::CreateMaybeMessage<::jasper::StatusResponse>(Arena*);
template<> ::jasper::TagName* Arena::CreateMaybeMessage<::jasper::TagName>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace jasper {

enum LogType {
  LOGUNKNOWN = 0,
  LOGBUILDLOGGERV2 = 1,
  LOGBUILDLOGGERV3 = 2,
  LOGDEFAULT = 3,
  LOGFILE = 4,
  LOGINHERIT = 5,
  LOGSPLUNK = 6,
  LOGSUMOLOGIC = 7,
  LOGINMEMORY = 8,
  LogType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LogType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LogType_IsValid(int value);
const LogType LogType_MIN = LOGUNKNOWN;
const LogType LogType_MAX = LOGINMEMORY;
const int LogType_ARRAYSIZE = LogType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogType_descriptor();
inline const ::std::string& LogType_Name(LogType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogType_descriptor(), value);
}
inline bool LogType_Parse(
    const ::std::string& name, LogType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogType>(
    LogType_descriptor(), name, value);
}
enum LogFormat {
  LOGFORMATUNKNOWN = 0,
  LOGFORMATDEFAULT = 1,
  LOGFORMATJSON = 2,
  LOGFORMATPLAIN = 3,
  LogFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LogFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LogFormat_IsValid(int value);
const LogFormat LogFormat_MIN = LOGFORMATUNKNOWN;
const LogFormat LogFormat_MAX = LOGFORMATPLAIN;
const int LogFormat_ARRAYSIZE = LogFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogFormat_descriptor();
inline const ::std::string& LogFormat_Name(LogFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogFormat_descriptor(), value);
}
inline bool LogFormat_Parse(
    const ::std::string& name, LogFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogFormat>(
    LogFormat_descriptor(), name, value);
}
enum FilterSpecifications {
  ALL = 0,
  RUNNING = 1,
  TERMINATED = 2,
  FAILED = 3,
  SUCCESSFUL = 4,
  FilterSpecifications_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FilterSpecifications_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FilterSpecifications_IsValid(int value);
const FilterSpecifications FilterSpecifications_MIN = ALL;
const FilterSpecifications FilterSpecifications_MAX = SUCCESSFUL;
const int FilterSpecifications_ARRAYSIZE = FilterSpecifications_MAX + 1;

const ::google::protobuf::EnumDescriptor* FilterSpecifications_descriptor();
inline const ::std::string& FilterSpecifications_Name(FilterSpecifications value) {
  return ::google::protobuf::internal::NameOfEnum(
    FilterSpecifications_descriptor(), value);
}
inline bool FilterSpecifications_Parse(
    const ::std::string& name, FilterSpecifications* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FilterSpecifications>(
    FilterSpecifications_descriptor(), name, value);
}
enum Signals {
  UNKNOWN = 0,
  TERMINATE = 1,
  KILL = 2,
  HANGUP = 3,
  INIT = 4,
  USER1 = 5,
  USER2 = 6,
  Signals_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Signals_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Signals_IsValid(int value);
const Signals Signals_MIN = UNKNOWN;
const Signals Signals_MAX = USER2;
const int Signals_ARRAYSIZE = Signals_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signals_descriptor();
inline const ::std::string& Signals_Name(Signals value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signals_descriptor(), value);
}
inline bool Signals_Parse(
    const ::std::string& name, Signals* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signals>(
    Signals_descriptor(), name, value);
}
enum ArchiveFormat {
  ARCHIVEUNKNOWN = 0,
  ARCHIVEAUTO = 1,
  ARCHIVETARGZ = 2,
  ARCHIVEZIP = 3,
  ArchiveFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ArchiveFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ArchiveFormat_IsValid(int value);
const ArchiveFormat ArchiveFormat_MIN = ARCHIVEUNKNOWN;
const ArchiveFormat ArchiveFormat_MAX = ARCHIVEZIP;
const int ArchiveFormat_ARRAYSIZE = ArchiveFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* ArchiveFormat_descriptor();
inline const ::std::string& ArchiveFormat_Name(ArchiveFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    ArchiveFormat_descriptor(), value);
}
inline bool ArchiveFormat_Parse(
    const ::std::string& name, ArchiveFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ArchiveFormat>(
    ArchiveFormat_descriptor(), name, value);
}
// ===================================================================

class Logger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.Logger) */ {
 public:
  Logger();
  virtual ~Logger();

  Logger(const Logger& from);

  inline Logger& operator=(const Logger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Logger(Logger&& from) noexcept
    : Logger() {
    *this = ::std::move(from);
  }

  inline Logger& operator=(Logger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Logger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Logger* internal_default_instance() {
    return reinterpret_cast<const Logger*>(
               &_Logger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Logger* other);
  friend void swap(Logger& a, Logger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Logger* New() const final {
    return CreateMaybeMessage<Logger>(NULL);
  }

  Logger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Logger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Logger& from);
  void MergeFrom(const Logger& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .jasper.LogOptions log_options = 2;
  bool has_log_options() const;
  void clear_log_options();
  static const int kLogOptionsFieldNumber = 2;
  private:
  const ::jasper::LogOptions& _internal_log_options() const;
  public:
  const ::jasper::LogOptions& log_options() const;
  ::jasper::LogOptions* release_log_options();
  ::jasper::LogOptions* mutable_log_options();
  void set_allocated_log_options(::jasper::LogOptions* log_options);

  // .jasper.LogType log_type = 1;
  void clear_log_type();
  static const int kLogTypeFieldNumber = 1;
  ::jasper::LogType log_type() const;
  void set_log_type(::jasper::LogType value);

  // @@protoc_insertion_point(class_scope:jasper.Logger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::jasper::LogOptions* log_options_;
  int log_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OutputOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.OutputOptions) */ {
 public:
  OutputOptions();
  virtual ~OutputOptions();

  OutputOptions(const OutputOptions& from);

  inline OutputOptions& operator=(const OutputOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OutputOptions(OutputOptions&& from) noexcept
    : OutputOptions() {
    *this = ::std::move(from);
  }

  inline OutputOptions& operator=(OutputOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OutputOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutputOptions* internal_default_instance() {
    return reinterpret_cast<const OutputOptions*>(
               &_OutputOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(OutputOptions* other);
  friend void swap(OutputOptions& a, OutputOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OutputOptions* New() const final {
    return CreateMaybeMessage<OutputOptions>(NULL);
  }

  OutputOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OutputOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OutputOptions& from);
  void MergeFrom(const OutputOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jasper.Logger loggers = 1;
  int loggers_size() const;
  void clear_loggers();
  static const int kLoggersFieldNumber = 1;
  ::jasper::Logger* mutable_loggers(int index);
  ::google::protobuf::RepeatedPtrField< ::jasper::Logger >*
      mutable_loggers();
  const ::jasper::Logger& loggers(int index) const;
  ::jasper::Logger* add_loggers();
  const ::google::protobuf::RepeatedPtrField< ::jasper::Logger >&
      loggers() const;

  // bool suppress_output = 2;
  void clear_suppress_output();
  static const int kSuppressOutputFieldNumber = 2;
  bool suppress_output() const;
  void set_suppress_output(bool value);

  // bool suppress_error = 3;
  void clear_suppress_error();
  static const int kSuppressErrorFieldNumber = 3;
  bool suppress_error() const;
  void set_suppress_error(bool value);

  // bool redirect_output_to_error = 4;
  void clear_redirect_output_to_error();
  static const int kRedirectOutputToErrorFieldNumber = 4;
  bool redirect_output_to_error() const;
  void set_redirect_output_to_error(bool value);

  // bool redirect_error_to_output = 5;
  void clear_redirect_error_to_output();
  static const int kRedirectErrorToOutputFieldNumber = 5;
  bool redirect_error_to_output() const;
  void set_redirect_error_to_output(bool value);

  // @@protoc_insertion_point(class_scope:jasper.OutputOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::jasper::Logger > loggers_;
  bool suppress_output_;
  bool suppress_error_;
  bool redirect_output_to_error_;
  bool redirect_error_to_output_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.LogOptions) */ {
 public:
  LogOptions();
  virtual ~LogOptions();

  LogOptions(const LogOptions& from);

  inline LogOptions& operator=(const LogOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogOptions(LogOptions&& from) noexcept
    : LogOptions() {
    *this = ::std::move(from);
  }

  inline LogOptions& operator=(LogOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogOptions* internal_default_instance() {
    return reinterpret_cast<const LogOptions*>(
               &_LogOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LogOptions* other);
  friend void swap(LogOptions& a, LogOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogOptions* New() const final {
    return CreateMaybeMessage<LogOptions>(NULL);
  }

  LogOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogOptions& from);
  void MergeFrom(const LogOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string default_prefix = 3;
  void clear_default_prefix();
  static const int kDefaultPrefixFieldNumber = 3;
  const ::std::string& default_prefix() const;
  void set_default_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_default_prefix(::std::string&& value);
  #endif
  void set_default_prefix(const char* value);
  void set_default_prefix(const char* value, size_t size);
  ::std::string* mutable_default_prefix();
  ::std::string* release_default_prefix();
  void set_allocated_default_prefix(::std::string* default_prefix);

  // string file_name = 4;
  void clear_file_name();
  static const int kFileNameFieldNumber = 4;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // string format = 5;
  void clear_format();
  static const int kFormatFieldNumber = 5;
  const ::std::string& format() const;
  void set_format(const ::std::string& value);
  #if LANG_CXX11
  void set_format(::std::string&& value);
  #endif
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  ::std::string* mutable_format();
  ::std::string* release_format();
  void set_allocated_format(::std::string* format);

  // string sumo_endpoint = 8;
  void clear_sumo_endpoint();
  static const int kSumoEndpointFieldNumber = 8;
  const ::std::string& sumo_endpoint() const;
  void set_sumo_endpoint(const ::std::string& value);
  #if LANG_CXX11
  void set_sumo_endpoint(::std::string&& value);
  #endif
  void set_sumo_endpoint(const char* value);
  void set_sumo_endpoint(const char* value, size_t size);
  ::std::string* mutable_sumo_endpoint();
  ::std::string* release_sumo_endpoint();
  void set_allocated_sumo_endpoint(::std::string* sumo_endpoint);

  // .jasper.BufferOptions buffer_options = 1;
  bool has_buffer_options() const;
  void clear_buffer_options();
  static const int kBufferOptionsFieldNumber = 1;
  private:
  const ::jasper::BufferOptions& _internal_buffer_options() const;
  public:
  const ::jasper::BufferOptions& buffer_options() const;
  ::jasper::BufferOptions* release_buffer_options();
  ::jasper::BufferOptions* mutable_buffer_options();
  void set_allocated_buffer_options(::jasper::BufferOptions* buffer_options);

  // .jasper.BuildloggerOptions buildlogger_options = 2;
  bool has_buildlogger_options() const;
  void clear_buildlogger_options();
  static const int kBuildloggerOptionsFieldNumber = 2;
  private:
  const ::jasper::BuildloggerOptions& _internal_buildlogger_options() const;
  public:
  const ::jasper::BuildloggerOptions& buildlogger_options() const;
  ::jasper::BuildloggerOptions* release_buildlogger_options();
  ::jasper::BuildloggerOptions* mutable_buildlogger_options();
  void set_allocated_buildlogger_options(::jasper::BuildloggerOptions* buildlogger_options);

  // .jasper.SplunkOptions splunk_options = 7;
  bool has_splunk_options() const;
  void clear_splunk_options();
  static const int kSplunkOptionsFieldNumber = 7;
  private:
  const ::jasper::SplunkOptions& _internal_splunk_options() const;
  public:
  const ::jasper::SplunkOptions& splunk_options() const;
  ::jasper::SplunkOptions* release_splunk_options();
  ::jasper::SplunkOptions* mutable_splunk_options();
  void set_allocated_splunk_options(::jasper::SplunkOptions* splunk_options);

  // int64 in_memory_cap = 6;
  void clear_in_memory_cap();
  static const int kInMemoryCapFieldNumber = 6;
  ::google::protobuf::int64 in_memory_cap() const;
  void set_in_memory_cap(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:jasper.LogOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr default_prefix_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::internal::ArenaStringPtr format_;
  ::google::protobuf::internal::ArenaStringPtr sumo_endpoint_;
  ::jasper::BufferOptions* buffer_options_;
  ::jasper::BuildloggerOptions* buildlogger_options_;
  ::jasper::SplunkOptions* splunk_options_;
  ::google::protobuf::int64 in_memory_cap_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BufferOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.BufferOptions) */ {
 public:
  BufferOptions();
  virtual ~BufferOptions();

  BufferOptions(const BufferOptions& from);

  inline BufferOptions& operator=(const BufferOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BufferOptions(BufferOptions&& from) noexcept
    : BufferOptions() {
    *this = ::std::move(from);
  }

  inline BufferOptions& operator=(BufferOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BufferOptions* internal_default_instance() {
    return reinterpret_cast<const BufferOptions*>(
               &_BufferOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BufferOptions* other);
  friend void swap(BufferOptions& a, BufferOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BufferOptions* New() const final {
    return CreateMaybeMessage<BufferOptions>(NULL);
  }

  BufferOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BufferOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BufferOptions& from);
  void MergeFrom(const BufferOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BufferOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 duration = 2;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  ::google::protobuf::int64 duration() const;
  void set_duration(::google::protobuf::int64 value);

  // int64 max_size = 3;
  void clear_max_size();
  static const int kMaxSizeFieldNumber = 3;
  ::google::protobuf::int64 max_size() const;
  void set_max_size(::google::protobuf::int64 value);

  // bool buffered = 1;
  void clear_buffered();
  static const int kBufferedFieldNumber = 1;
  bool buffered() const;
  void set_buffered(bool value);

  // @@protoc_insertion_point(class_scope:jasper.BufferOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 duration_;
  ::google::protobuf::int64 max_size_;
  bool buffered_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BuildloggerOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.BuildloggerOptions) */ {
 public:
  BuildloggerOptions();
  virtual ~BuildloggerOptions();

  BuildloggerOptions(const BuildloggerOptions& from);

  inline BuildloggerOptions& operator=(const BuildloggerOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuildloggerOptions(BuildloggerOptions&& from) noexcept
    : BuildloggerOptions() {
    *this = ::std::move(from);
  }

  inline BuildloggerOptions& operator=(BuildloggerOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildloggerOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildloggerOptions* internal_default_instance() {
    return reinterpret_cast<const BuildloggerOptions*>(
               &_BuildloggerOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BuildloggerOptions* other);
  friend void swap(BuildloggerOptions& a, BuildloggerOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuildloggerOptions* New() const final {
    return CreateMaybeMessage<BuildloggerOptions>(NULL);
  }

  BuildloggerOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuildloggerOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BuildloggerOptions& from);
  void MergeFrom(const BuildloggerOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildloggerOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 2;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // string phase = 4;
  void clear_phase();
  static const int kPhaseFieldNumber = 4;
  const ::std::string& phase() const;
  void set_phase(const ::std::string& value);
  #if LANG_CXX11
  void set_phase(::std::string&& value);
  #endif
  void set_phase(const char* value);
  void set_phase(const char* value, size_t size);
  ::std::string* mutable_phase();
  ::std::string* release_phase();
  void set_allocated_phase(::std::string* phase);

  // string builder = 5;
  void clear_builder();
  static const int kBuilderFieldNumber = 5;
  const ::std::string& builder() const;
  void set_builder(const ::std::string& value);
  #if LANG_CXX11
  void set_builder(::std::string&& value);
  #endif
  void set_builder(const char* value);
  void set_builder(const char* value, size_t size);
  ::std::string* mutable_builder();
  ::std::string* release_builder();
  void set_allocated_builder(::std::string* builder);

  // string test = 6;
  void clear_test();
  static const int kTestFieldNumber = 6;
  const ::std::string& test() const;
  void set_test(const ::std::string& value);
  #if LANG_CXX11
  void set_test(::std::string&& value);
  #endif
  void set_test(const char* value);
  void set_test(const char* value, size_t size);
  ::std::string* mutable_test();
  ::std::string* release_test();
  void set_allocated_test(::std::string* test);

  // string command = 7;
  void clear_command();
  static const int kCommandFieldNumber = 7;
  const ::std::string& command() const;
  void set_command(const ::std::string& value);
  #if LANG_CXX11
  void set_command(::std::string&& value);
  #endif
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  ::std::string* mutable_command();
  ::std::string* release_command();
  void set_allocated_command(::std::string* command);

  // int64 number = 3;
  void clear_number();
  static const int kNumberFieldNumber = 3;
  ::google::protobuf::int64 number() const;
  void set_number(::google::protobuf::int64 value);

  // bool create_test = 1;
  void clear_create_test();
  static const int kCreateTestFieldNumber = 1;
  bool create_test() const;
  void set_create_test(bool value);

  // @@protoc_insertion_point(class_scope:jasper.BuildloggerOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr phase_;
  ::google::protobuf::internal::ArenaStringPtr builder_;
  ::google::protobuf::internal::ArenaStringPtr test_;
  ::google::protobuf::internal::ArenaStringPtr command_;
  ::google::protobuf::int64 number_;
  bool create_test_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SplunkOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.SplunkOptions) */ {
 public:
  SplunkOptions();
  virtual ~SplunkOptions();

  SplunkOptions(const SplunkOptions& from);

  inline SplunkOptions& operator=(const SplunkOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SplunkOptions(SplunkOptions&& from) noexcept
    : SplunkOptions() {
    *this = ::std::move(from);
  }

  inline SplunkOptions& operator=(SplunkOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SplunkOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplunkOptions* internal_default_instance() {
    return reinterpret_cast<const SplunkOptions*>(
               &_SplunkOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SplunkOptions* other);
  friend void swap(SplunkOptions& a, SplunkOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SplunkOptions* New() const final {
    return CreateMaybeMessage<SplunkOptions>(NULL);
  }

  SplunkOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SplunkOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SplunkOptions& from);
  void MergeFrom(const SplunkOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SplunkOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // string token = 2;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // string channel = 3;
  void clear_channel();
  static const int kChannelFieldNumber = 3;
  const ::std::string& channel() const;
  void set_channel(const ::std::string& value);
  #if LANG_CXX11
  void set_channel(::std::string&& value);
  #endif
  void set_channel(const char* value);
  void set_channel(const char* value, size_t size);
  ::std::string* mutable_channel();
  ::std::string* release_channel();
  void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:jasper.SplunkOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::internal::ArenaStringPtr channel_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateOptions_EnvironmentEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<CreateOptions_EnvironmentEntry_DoNotUse,
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<CreateOptions_EnvironmentEntry_DoNotUse,
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  CreateOptions_EnvironmentEntry_DoNotUse();
  CreateOptions_EnvironmentEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const CreateOptions_EnvironmentEntry_DoNotUse& other);
  static const CreateOptions_EnvironmentEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateOptions_EnvironmentEntry_DoNotUse*>(&_CreateOptions_EnvironmentEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class CreateOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.CreateOptions) */ {
 public:
  CreateOptions();
  virtual ~CreateOptions();

  CreateOptions(const CreateOptions& from);

  inline CreateOptions& operator=(const CreateOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateOptions(CreateOptions&& from) noexcept
    : CreateOptions() {
    *this = ::std::move(from);
  }

  inline CreateOptions& operator=(CreateOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateOptions* internal_default_instance() {
    return reinterpret_cast<const CreateOptions*>(
               &_CreateOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CreateOptions* other);
  friend void swap(CreateOptions& a, CreateOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateOptions* New() const final {
    return CreateMaybeMessage<CreateOptions>(NULL);
  }

  CreateOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateOptions& from);
  void MergeFrom(const CreateOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string args = 1;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 1;
  const ::std::string& args(int index) const;
  ::std::string* mutable_args(int index);
  void set_args(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_args(int index, ::std::string&& value);
  #endif
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  ::std::string* add_args();
  void add_args(const ::std::string& value);
  #if LANG_CXX11
  void add_args(::std::string&& value);
  #endif
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // map<string, string> environment = 3;
  int environment_size() const;
  void clear_environment();
  static const int kEnvironmentFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      environment() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_environment();

  // repeated string tags = 6;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 6;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // repeated .jasper.CreateOptions on_success = 7;
  int on_success_size() const;
  void clear_on_success();
  static const int kOnSuccessFieldNumber = 7;
  ::jasper::CreateOptions* mutable_on_success(int index);
  ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >*
      mutable_on_success();
  const ::jasper::CreateOptions& on_success(int index) const;
  ::jasper::CreateOptions* add_on_success();
  const ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >&
      on_success() const;

  // repeated .jasper.CreateOptions on_failure = 8;
  int on_failure_size() const;
  void clear_on_failure();
  static const int kOnFailureFieldNumber = 8;
  ::jasper::CreateOptions* mutable_on_failure(int index);
  ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >*
      mutable_on_failure();
  const ::jasper::CreateOptions& on_failure(int index) const;
  ::jasper::CreateOptions* add_on_failure();
  const ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >&
      on_failure() const;

  // repeated .jasper.CreateOptions on_timeout = 9;
  int on_timeout_size() const;
  void clear_on_timeout();
  static const int kOnTimeoutFieldNumber = 9;
  ::jasper::CreateOptions* mutable_on_timeout(int index);
  ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >*
      mutable_on_timeout();
  const ::jasper::CreateOptions& on_timeout(int index) const;
  ::jasper::CreateOptions* add_on_timeout();
  const ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >&
      on_timeout() const;

  // string working_directory = 2;
  void clear_working_directory();
  static const int kWorkingDirectoryFieldNumber = 2;
  const ::std::string& working_directory() const;
  void set_working_directory(const ::std::string& value);
  #if LANG_CXX11
  void set_working_directory(::std::string&& value);
  #endif
  void set_working_directory(const char* value);
  void set_working_directory(const char* value, size_t size);
  ::std::string* mutable_working_directory();
  ::std::string* release_working_directory();
  void set_allocated_working_directory(::std::string* working_directory);

  // .jasper.OutputOptions output = 10;
  bool has_output() const;
  void clear_output();
  static const int kOutputFieldNumber = 10;
  private:
  const ::jasper::OutputOptions& _internal_output() const;
  public:
  const ::jasper::OutputOptions& output() const;
  ::jasper::OutputOptions* release_output();
  ::jasper::OutputOptions* mutable_output();
  void set_allocated_output(::jasper::OutputOptions* output);

  // int64 timeout_seconds = 5;
  void clear_timeout_seconds();
  static const int kTimeoutSecondsFieldNumber = 5;
  ::google::protobuf::int64 timeout_seconds() const;
  void set_timeout_seconds(::google::protobuf::int64 value);

  // bool override_environ = 4;
  void clear_override_environ();
  static const int kOverrideEnvironFieldNumber = 4;
  bool override_environ() const;
  void set_override_environ(bool value);

  // @@protoc_insertion_point(class_scope:jasper.CreateOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::google::protobuf::internal::MapField<
      CreateOptions_EnvironmentEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > environment_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions > on_success_;
  ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions > on_failure_;
  ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions > on_timeout_;
  ::google::protobuf::internal::ArenaStringPtr working_directory_;
  ::jasper::OutputOptions* output_;
  ::google::protobuf::int64 timeout_seconds_;
  bool override_environ_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcessInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.ProcessInfo) */ {
 public:
  ProcessInfo();
  virtual ~ProcessInfo();

  ProcessInfo(const ProcessInfo& from);

  inline ProcessInfo& operator=(const ProcessInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcessInfo(ProcessInfo&& from) noexcept
    : ProcessInfo() {
    *this = ::std::move(from);
  }

  inline ProcessInfo& operator=(ProcessInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessInfo* internal_default_instance() {
    return reinterpret_cast<const ProcessInfo*>(
               &_ProcessInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ProcessInfo* other);
  friend void swap(ProcessInfo& a, ProcessInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcessInfo* New() const final {
    return CreateMaybeMessage<ProcessInfo>(NULL);
  }

  ProcessInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcessInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcessInfo& from);
  void MergeFrom(const ProcessInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string host_id = 3;
  void clear_host_id();
  static const int kHostIdFieldNumber = 3;
  const ::std::string& host_id() const;
  void set_host_id(const ::std::string& value);
  #if LANG_CXX11
  void set_host_id(::std::string&& value);
  #endif
  void set_host_id(const char* value);
  void set_host_id(const char* value, size_t size);
  ::std::string* mutable_host_id();
  ::std::string* release_host_id();
  void set_allocated_host_id(::std::string* host_id);

  // .jasper.CreateOptions options = 8;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 8;
  private:
  const ::jasper::CreateOptions& _internal_options() const;
  public:
  const ::jasper::CreateOptions& options() const;
  ::jasper::CreateOptions* release_options();
  ::jasper::CreateOptions* mutable_options();
  void set_allocated_options(::jasper::CreateOptions* options);

  // int64 pid = 2;
  void clear_pid();
  static const int kPidFieldNumber = 2;
  ::google::protobuf::int64 pid() const;
  void set_pid(::google::protobuf::int64 value);

  // bool running = 4;
  void clear_running();
  static const int kRunningFieldNumber = 4;
  bool running() const;
  void set_running(bool value);

  // bool successful = 5;
  void clear_successful();
  static const int kSuccessfulFieldNumber = 5;
  bool successful() const;
  void set_successful(bool value);

  // bool complete = 6;
  void clear_complete();
  static const int kCompleteFieldNumber = 6;
  bool complete() const;
  void set_complete(bool value);

  // bool timedout = 7;
  void clear_timedout();
  static const int kTimedoutFieldNumber = 7;
  bool timedout() const;
  void set_timedout(bool value);

  // @@protoc_insertion_point(class_scope:jasper.ProcessInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr host_id_;
  ::jasper::CreateOptions* options_;
  ::google::protobuf::int64 pid_;
  bool running_;
  bool successful_;
  bool complete_;
  bool timedout_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.StatusResponse) */ {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(StatusResponse* other);
  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const final {
    return CreateMaybeMessage<StatusResponse>(NULL);
  }

  StatusResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string host_id = 1;
  void clear_host_id();
  static const int kHostIdFieldNumber = 1;
  const ::std::string& host_id() const;
  void set_host_id(const ::std::string& value);
  #if LANG_CXX11
  void set_host_id(::std::string&& value);
  #endif
  void set_host_id(const char* value);
  void set_host_id(const char* value, size_t size);
  ::std::string* mutable_host_id();
  ::std::string* release_host_id();
  void set_allocated_host_id(::std::string* host_id);

  // bool active = 2;
  void clear_active();
  static const int kActiveFieldNumber = 2;
  bool active() const;
  void set_active(bool value);

  // @@protoc_insertion_point(class_scope:jasper.StatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr host_id_;
  bool active_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Filter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.Filter) */ {
 public:
  Filter();
  virtual ~Filter();

  Filter(const Filter& from);

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(Filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Filter* other);
  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Filter* New() const final {
    return CreateMaybeMessage<Filter>(NULL);
  }

  Filter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Filter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Filter& from);
  void MergeFrom(const Filter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .jasper.FilterSpecifications name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  ::jasper::FilterSpecifications name() const;
  void set_name(::jasper::FilterSpecifications value);

  // @@protoc_insertion_point(class_scope:jasper.Filter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignalProcess : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.SignalProcess) */ {
 public:
  SignalProcess();
  virtual ~SignalProcess();

  SignalProcess(const SignalProcess& from);

  inline SignalProcess& operator=(const SignalProcess& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignalProcess(SignalProcess&& from) noexcept
    : SignalProcess() {
    *this = ::std::move(from);
  }

  inline SignalProcess& operator=(SignalProcess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalProcess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalProcess* internal_default_instance() {
    return reinterpret_cast<const SignalProcess*>(
               &_SignalProcess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SignalProcess* other);
  friend void swap(SignalProcess& a, SignalProcess& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignalProcess* New() const final {
    return CreateMaybeMessage<SignalProcess>(NULL);
  }

  SignalProcess* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignalProcess>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SignalProcess& from);
  void MergeFrom(const SignalProcess& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalProcess* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .jasper.JasperProcessID ProcessID = 1;
  bool has_processid() const;
  void clear_processid();
  static const int kProcessIDFieldNumber = 1;
  private:
  const ::jasper::JasperProcessID& _internal_processid() const;
  public:
  const ::jasper::JasperProcessID& processid() const;
  ::jasper::JasperProcessID* release_processid();
  ::jasper::JasperProcessID* mutable_processid();
  void set_allocated_processid(::jasper::JasperProcessID* processid);

  // .jasper.Signals signal = 2;
  void clear_signal();
  static const int kSignalFieldNumber = 2;
  ::jasper::Signals signal() const;
  void set_signal(::jasper::Signals value);

  // @@protoc_insertion_point(class_scope:jasper.SignalProcess)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::jasper::JasperProcessID* processid_;
  int signal_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TagName : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.TagName) */ {
 public:
  TagName();
  virtual ~TagName();

  TagName(const TagName& from);

  inline TagName& operator=(const TagName& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TagName(TagName&& from) noexcept
    : TagName() {
    *this = ::std::move(from);
  }

  inline TagName& operator=(TagName&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TagName& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TagName* internal_default_instance() {
    return reinterpret_cast<const TagName*>(
               &_TagName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(TagName* other);
  friend void swap(TagName& a, TagName& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TagName* New() const final {
    return CreateMaybeMessage<TagName>(NULL);
  }

  TagName* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TagName>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TagName& from);
  void MergeFrom(const TagName& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagName* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:jasper.TagName)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcessTags : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.ProcessTags) */ {
 public:
  ProcessTags();
  virtual ~ProcessTags();

  ProcessTags(const ProcessTags& from);

  inline ProcessTags& operator=(const ProcessTags& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcessTags(ProcessTags&& from) noexcept
    : ProcessTags() {
    *this = ::std::move(from);
  }

  inline ProcessTags& operator=(ProcessTags&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessTags& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessTags* internal_default_instance() {
    return reinterpret_cast<const ProcessTags*>(
               &_ProcessTags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ProcessTags* other);
  friend void swap(ProcessTags& a, ProcessTags& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcessTags* New() const final {
    return CreateMaybeMessage<ProcessTags>(NULL);
  }

  ProcessTags* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcessTags>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcessTags& from);
  void MergeFrom(const ProcessTags& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessTags* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tags = 2;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 2;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // string processID = 1;
  void clear_processid();
  static const int kProcessIDFieldNumber = 1;
  const ::std::string& processid() const;
  void set_processid(const ::std::string& value);
  #if LANG_CXX11
  void set_processid(::std::string&& value);
  #endif
  void set_processid(const char* value);
  void set_processid(const char* value, size_t size);
  ::std::string* mutable_processid();
  ::std::string* release_processid();
  void set_allocated_processid(::std::string* processid);

  // @@protoc_insertion_point(class_scope:jasper.ProcessTags)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::internal::ArenaStringPtr processid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JasperProcessID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.JasperProcessID) */ {
 public:
  JasperProcessID();
  virtual ~JasperProcessID();

  JasperProcessID(const JasperProcessID& from);

  inline JasperProcessID& operator=(const JasperProcessID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JasperProcessID(JasperProcessID&& from) noexcept
    : JasperProcessID() {
    *this = ::std::move(from);
  }

  inline JasperProcessID& operator=(JasperProcessID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JasperProcessID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JasperProcessID* internal_default_instance() {
    return reinterpret_cast<const JasperProcessID*>(
               &_JasperProcessID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(JasperProcessID* other);
  friend void swap(JasperProcessID& a, JasperProcessID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JasperProcessID* New() const final {
    return CreateMaybeMessage<JasperProcessID>(NULL);
  }

  JasperProcessID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JasperProcessID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JasperProcessID& from);
  void MergeFrom(const JasperProcessID& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JasperProcessID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:jasper.JasperProcessID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationOutcome : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.OperationOutcome) */ {
 public:
  OperationOutcome();
  virtual ~OperationOutcome();

  OperationOutcome(const OperationOutcome& from);

  inline OperationOutcome& operator=(const OperationOutcome& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationOutcome(OperationOutcome&& from) noexcept
    : OperationOutcome() {
    *this = ::std::move(from);
  }

  inline OperationOutcome& operator=(OperationOutcome&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationOutcome& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationOutcome* internal_default_instance() {
    return reinterpret_cast<const OperationOutcome*>(
               &_OperationOutcome_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(OperationOutcome* other);
  friend void swap(OperationOutcome& a, OperationOutcome& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationOutcome* New() const final {
    return CreateMaybeMessage<OperationOutcome>(NULL);
  }

  OperationOutcome* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperationOutcome>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperationOutcome& from);
  void MergeFrom(const OperationOutcome& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationOutcome* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:jasper.OperationOutcome)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BuildOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.BuildOptions) */ {
 public:
  BuildOptions();
  virtual ~BuildOptions();

  BuildOptions(const BuildOptions& from);

  inline BuildOptions& operator=(const BuildOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuildOptions(BuildOptions&& from) noexcept
    : BuildOptions() {
    *this = ::std::move(from);
  }

  inline BuildOptions& operator=(BuildOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildOptions* internal_default_instance() {
    return reinterpret_cast<const BuildOptions*>(
               &_BuildOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(BuildOptions* other);
  friend void swap(BuildOptions& a, BuildOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuildOptions* New() const final {
    return CreateMaybeMessage<BuildOptions>(NULL);
  }

  BuildOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuildOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BuildOptions& from);
  void MergeFrom(const BuildOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target = 1;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  const ::std::string& target() const;
  void set_target(const ::std::string& value);
  #if LANG_CXX11
  void set_target(::std::string&& value);
  #endif
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  ::std::string* mutable_target();
  ::std::string* release_target();
  void set_allocated_target(::std::string* target);

  // string arch = 2;
  void clear_arch();
  static const int kArchFieldNumber = 2;
  const ::std::string& arch() const;
  void set_arch(const ::std::string& value);
  #if LANG_CXX11
  void set_arch(::std::string&& value);
  #endif
  void set_arch(const char* value);
  void set_arch(const char* value, size_t size);
  ::std::string* mutable_arch();
  ::std::string* release_arch();
  void set_allocated_arch(::std::string* arch);

  // string edition = 3;
  void clear_edition();
  static const int kEditionFieldNumber = 3;
  const ::std::string& edition() const;
  void set_edition(const ::std::string& value);
  #if LANG_CXX11
  void set_edition(::std::string&& value);
  #endif
  void set_edition(const char* value);
  void set_edition(const char* value, size_t size);
  ::std::string* mutable_edition();
  ::std::string* release_edition();
  void set_allocated_edition(::std::string* edition);

  // bool debug = 4;
  void clear_debug();
  static const int kDebugFieldNumber = 4;
  bool debug() const;
  void set_debug(bool value);

  // @@protoc_insertion_point(class_scope:jasper.BuildOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_;
  ::google::protobuf::internal::ArenaStringPtr arch_;
  ::google::protobuf::internal::ArenaStringPtr edition_;
  bool debug_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MongoDBDownloadOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.MongoDBDownloadOptions) */ {
 public:
  MongoDBDownloadOptions();
  virtual ~MongoDBDownloadOptions();

  MongoDBDownloadOptions(const MongoDBDownloadOptions& from);

  inline MongoDBDownloadOptions& operator=(const MongoDBDownloadOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MongoDBDownloadOptions(MongoDBDownloadOptions&& from) noexcept
    : MongoDBDownloadOptions() {
    *this = ::std::move(from);
  }

  inline MongoDBDownloadOptions& operator=(MongoDBDownloadOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MongoDBDownloadOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MongoDBDownloadOptions* internal_default_instance() {
    return reinterpret_cast<const MongoDBDownloadOptions*>(
               &_MongoDBDownloadOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(MongoDBDownloadOptions* other);
  friend void swap(MongoDBDownloadOptions& a, MongoDBDownloadOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MongoDBDownloadOptions* New() const final {
    return CreateMaybeMessage<MongoDBDownloadOptions>(NULL);
  }

  MongoDBDownloadOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MongoDBDownloadOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MongoDBDownloadOptions& from);
  void MergeFrom(const MongoDBDownloadOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoDBDownloadOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string releases = 3;
  int releases_size() const;
  void clear_releases();
  static const int kReleasesFieldNumber = 3;
  const ::std::string& releases(int index) const;
  ::std::string* mutable_releases(int index);
  void set_releases(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_releases(int index, ::std::string&& value);
  #endif
  void set_releases(int index, const char* value);
  void set_releases(int index, const char* value, size_t size);
  ::std::string* add_releases();
  void add_releases(const ::std::string& value);
  #if LANG_CXX11
  void add_releases(::std::string&& value);
  #endif
  void add_releases(const char* value);
  void add_releases(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& releases() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_releases();

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // .jasper.BuildOptions build_options = 1;
  bool has_build_options() const;
  void clear_build_options();
  static const int kBuildOptionsFieldNumber = 1;
  private:
  const ::jasper::BuildOptions& _internal_build_options() const;
  public:
  const ::jasper::BuildOptions& build_options() const;
  ::jasper::BuildOptions* release_build_options();
  ::jasper::BuildOptions* mutable_build_options();
  void set_allocated_build_options(::jasper::BuildOptions* build_options);

  // @@protoc_insertion_point(class_scope:jasper.MongoDBDownloadOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> releases_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::jasper::BuildOptions* build_options_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CacheOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.CacheOptions) */ {
 public:
  CacheOptions();
  virtual ~CacheOptions();

  CacheOptions(const CacheOptions& from);

  inline CacheOptions& operator=(const CacheOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CacheOptions(CacheOptions&& from) noexcept
    : CacheOptions() {
    *this = ::std::move(from);
  }

  inline CacheOptions& operator=(CacheOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CacheOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CacheOptions* internal_default_instance() {
    return reinterpret_cast<const CacheOptions*>(
               &_CacheOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CacheOptions* other);
  friend void swap(CacheOptions& a, CacheOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CacheOptions* New() const final {
    return CreateMaybeMessage<CacheOptions>(NULL);
  }

  CacheOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CacheOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CacheOptions& from);
  void MergeFrom(const CacheOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 prune_delay = 2;
  void clear_prune_delay();
  static const int kPruneDelayFieldNumber = 2;
  ::google::protobuf::int64 prune_delay() const;
  void set_prune_delay(::google::protobuf::int64 value);

  // int64 max_size = 3;
  void clear_max_size();
  static const int kMaxSizeFieldNumber = 3;
  ::google::protobuf::int64 max_size() const;
  void set_max_size(::google::protobuf::int64 value);

  // bool disabled = 1;
  void clear_disabled();
  static const int kDisabledFieldNumber = 1;
  bool disabled() const;
  void set_disabled(bool value);

  // @@protoc_insertion_point(class_scope:jasper.CacheOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 prune_delay_;
  ::google::protobuf::int64 max_size_;
  bool disabled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ArchiveOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.ArchiveOptions) */ {
 public:
  ArchiveOptions();
  virtual ~ArchiveOptions();

  ArchiveOptions(const ArchiveOptions& from);

  inline ArchiveOptions& operator=(const ArchiveOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArchiveOptions(ArchiveOptions&& from) noexcept
    : ArchiveOptions() {
    *this = ::std::move(from);
  }

  inline ArchiveOptions& operator=(ArchiveOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArchiveOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArchiveOptions* internal_default_instance() {
    return reinterpret_cast<const ArchiveOptions*>(
               &_ArchiveOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ArchiveOptions* other);
  friend void swap(ArchiveOptions& a, ArchiveOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArchiveOptions* New() const final {
    return CreateMaybeMessage<ArchiveOptions>(NULL);
  }

  ArchiveOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArchiveOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArchiveOptions& from);
  void MergeFrom(const ArchiveOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArchiveOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_path = 3;
  void clear_target_path();
  static const int kTargetPathFieldNumber = 3;
  const ::std::string& target_path() const;
  void set_target_path(const ::std::string& value);
  #if LANG_CXX11
  void set_target_path(::std::string&& value);
  #endif
  void set_target_path(const char* value);
  void set_target_path(const char* value, size_t size);
  ::std::string* mutable_target_path();
  ::std::string* release_target_path();
  void set_allocated_target_path(::std::string* target_path);

  // bool should_extract = 1;
  void clear_should_extract();
  static const int kShouldExtractFieldNumber = 1;
  bool should_extract() const;
  void set_should_extract(bool value);

  // .jasper.ArchiveFormat format = 2;
  void clear_format();
  static const int kFormatFieldNumber = 2;
  ::jasper::ArchiveFormat format() const;
  void set_format(::jasper::ArchiveFormat value);

  // @@protoc_insertion_point(class_scope:jasper.ArchiveOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_path_;
  bool should_extract_;
  int format_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DownloadInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.DownloadInfo) */ {
 public:
  DownloadInfo();
  virtual ~DownloadInfo();

  DownloadInfo(const DownloadInfo& from);

  inline DownloadInfo& operator=(const DownloadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DownloadInfo(DownloadInfo&& from) noexcept
    : DownloadInfo() {
    *this = ::std::move(from);
  }

  inline DownloadInfo& operator=(DownloadInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DownloadInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadInfo* internal_default_instance() {
    return reinterpret_cast<const DownloadInfo*>(
               &_DownloadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(DownloadInfo* other);
  friend void swap(DownloadInfo& a, DownloadInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DownloadInfo* New() const final {
    return CreateMaybeMessage<DownloadInfo>(NULL);
  }

  DownloadInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DownloadInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DownloadInfo& from);
  void MergeFrom(const DownloadInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // .jasper.ArchiveOptions archive_opts = 3;
  bool has_archive_opts() const;
  void clear_archive_opts();
  static const int kArchiveOptsFieldNumber = 3;
  private:
  const ::jasper::ArchiveOptions& _internal_archive_opts() const;
  public:
  const ::jasper::ArchiveOptions& archive_opts() const;
  ::jasper::ArchiveOptions* release_archive_opts();
  ::jasper::ArchiveOptions* mutable_archive_opts();
  void set_allocated_archive_opts(::jasper::ArchiveOptions* archive_opts);

  // @@protoc_insertion_point(class_scope:jasper.DownloadInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::jasper::ArchiveOptions* archive_opts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BuildloggerURLs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jasper.BuildloggerURLs) */ {
 public:
  BuildloggerURLs();
  virtual ~BuildloggerURLs();

  BuildloggerURLs(const BuildloggerURLs& from);

  inline BuildloggerURLs& operator=(const BuildloggerURLs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuildloggerURLs(BuildloggerURLs&& from) noexcept
    : BuildloggerURLs() {
    *this = ::std::move(from);
  }

  inline BuildloggerURLs& operator=(BuildloggerURLs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildloggerURLs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildloggerURLs* internal_default_instance() {
    return reinterpret_cast<const BuildloggerURLs*>(
               &_BuildloggerURLs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(BuildloggerURLs* other);
  friend void swap(BuildloggerURLs& a, BuildloggerURLs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuildloggerURLs* New() const final {
    return CreateMaybeMessage<BuildloggerURLs>(NULL);
  }

  BuildloggerURLs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuildloggerURLs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BuildloggerURLs& from);
  void MergeFrom(const BuildloggerURLs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildloggerURLs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string urls = 1;
  int urls_size() const;
  void clear_urls();
  static const int kUrlsFieldNumber = 1;
  const ::std::string& urls(int index) const;
  ::std::string* mutable_urls(int index);
  void set_urls(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_urls(int index, ::std::string&& value);
  #endif
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  ::std::string* add_urls();
  void add_urls(const ::std::string& value);
  #if LANG_CXX11
  void add_urls(::std::string&& value);
  #endif
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& urls() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_urls();

  // @@protoc_insertion_point(class_scope:jasper.BuildloggerURLs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> urls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_jasper_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Logger

// .jasper.LogType log_type = 1;
inline void Logger::clear_log_type() {
  log_type_ = 0;
}
inline ::jasper::LogType Logger::log_type() const {
  // @@protoc_insertion_point(field_get:jasper.Logger.log_type)
  return static_cast< ::jasper::LogType >(log_type_);
}
inline void Logger::set_log_type(::jasper::LogType value) {

  log_type_ = value;
  // @@protoc_insertion_point(field_set:jasper.Logger.log_type)
}

// .jasper.LogOptions log_options = 2;
inline bool Logger::has_log_options() const {
  return this != internal_default_instance() && log_options_ != NULL;
}
inline void Logger::clear_log_options() {
  if (GetArenaNoVirtual() == NULL && log_options_ != NULL) {
    delete log_options_;
  }
  log_options_ = NULL;
}
inline const ::jasper::LogOptions& Logger::_internal_log_options() const {
  return *log_options_;
}
inline const ::jasper::LogOptions& Logger::log_options() const {
  const ::jasper::LogOptions* p = log_options_;
  // @@protoc_insertion_point(field_get:jasper.Logger.log_options)
  return p != NULL ? *p : *reinterpret_cast<const ::jasper::LogOptions*>(
      &::jasper::_LogOptions_default_instance_);
}
inline ::jasper::LogOptions* Logger::release_log_options() {
  // @@protoc_insertion_point(field_release:jasper.Logger.log_options)

  ::jasper::LogOptions* temp = log_options_;
  log_options_ = NULL;
  return temp;
}
inline ::jasper::LogOptions* Logger::mutable_log_options() {

  if (log_options_ == NULL) {
    auto* p = CreateMaybeMessage<::jasper::LogOptions>(GetArenaNoVirtual());
    log_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:jasper.Logger.log_options)
  return log_options_;
}
inline void Logger::set_allocated_log_options(::jasper::LogOptions* log_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete log_options_;
  }
  if (log_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      log_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, log_options, submessage_arena);
    }

  } else {

  }
  log_options_ = log_options;
  // @@protoc_insertion_point(field_set_allocated:jasper.Logger.log_options)
}

// -------------------------------------------------------------------

// OutputOptions

// repeated .jasper.Logger loggers = 1;
inline int OutputOptions::loggers_size() const {
  return loggers_.size();
}
inline void OutputOptions::clear_loggers() {
  loggers_.Clear();
}
inline ::jasper::Logger* OutputOptions::mutable_loggers(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.OutputOptions.loggers)
  return loggers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::jasper::Logger >*
OutputOptions::mutable_loggers() {
  // @@protoc_insertion_point(field_mutable_list:jasper.OutputOptions.loggers)
  return &loggers_;
}
inline const ::jasper::Logger& OutputOptions::loggers(int index) const {
  // @@protoc_insertion_point(field_get:jasper.OutputOptions.loggers)
  return loggers_.Get(index);
}
inline ::jasper::Logger* OutputOptions::add_loggers() {
  // @@protoc_insertion_point(field_add:jasper.OutputOptions.loggers)
  return loggers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jasper::Logger >&
OutputOptions::loggers() const {
  // @@protoc_insertion_point(field_list:jasper.OutputOptions.loggers)
  return loggers_;
}

// bool suppress_output = 2;
inline void OutputOptions::clear_suppress_output() {
  suppress_output_ = false;
}
inline bool OutputOptions::suppress_output() const {
  // @@protoc_insertion_point(field_get:jasper.OutputOptions.suppress_output)
  return suppress_output_;
}
inline void OutputOptions::set_suppress_output(bool value) {

  suppress_output_ = value;
  // @@protoc_insertion_point(field_set:jasper.OutputOptions.suppress_output)
}

// bool suppress_error = 3;
inline void OutputOptions::clear_suppress_error() {
  suppress_error_ = false;
}
inline bool OutputOptions::suppress_error() const {
  // @@protoc_insertion_point(field_get:jasper.OutputOptions.suppress_error)
  return suppress_error_;
}
inline void OutputOptions::set_suppress_error(bool value) {

  suppress_error_ = value;
  // @@protoc_insertion_point(field_set:jasper.OutputOptions.suppress_error)
}

// bool redirect_output_to_error = 4;
inline void OutputOptions::clear_redirect_output_to_error() {
  redirect_output_to_error_ = false;
}
inline bool OutputOptions::redirect_output_to_error() const {
  // @@protoc_insertion_point(field_get:jasper.OutputOptions.redirect_output_to_error)
  return redirect_output_to_error_;
}
inline void OutputOptions::set_redirect_output_to_error(bool value) {

  redirect_output_to_error_ = value;
  // @@protoc_insertion_point(field_set:jasper.OutputOptions.redirect_output_to_error)
}

// bool redirect_error_to_output = 5;
inline void OutputOptions::clear_redirect_error_to_output() {
  redirect_error_to_output_ = false;
}
inline bool OutputOptions::redirect_error_to_output() const {
  // @@protoc_insertion_point(field_get:jasper.OutputOptions.redirect_error_to_output)
  return redirect_error_to_output_;
}
inline void OutputOptions::set_redirect_error_to_output(bool value) {

  redirect_error_to_output_ = value;
  // @@protoc_insertion_point(field_set:jasper.OutputOptions.redirect_error_to_output)
}

// -------------------------------------------------------------------

// LogOptions

// .jasper.BufferOptions buffer_options = 1;
inline bool LogOptions::has_buffer_options() const {
  return this != internal_default_instance() && buffer_options_ != NULL;
}
inline void LogOptions::clear_buffer_options() {
  if (GetArenaNoVirtual() == NULL && buffer_options_ != NULL) {
    delete buffer_options_;
  }
  buffer_options_ = NULL;
}
inline const ::jasper::BufferOptions& LogOptions::_internal_buffer_options() const {
  return *buffer_options_;
}
inline const ::jasper::BufferOptions& LogOptions::buffer_options() const {
  const ::jasper::BufferOptions* p = buffer_options_;
  // @@protoc_insertion_point(field_get:jasper.LogOptions.buffer_options)
  return p != NULL ? *p : *reinterpret_cast<const ::jasper::BufferOptions*>(
      &::jasper::_BufferOptions_default_instance_);
}
inline ::jasper::BufferOptions* LogOptions::release_buffer_options() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.buffer_options)

  ::jasper::BufferOptions* temp = buffer_options_;
  buffer_options_ = NULL;
  return temp;
}
inline ::jasper::BufferOptions* LogOptions::mutable_buffer_options() {

  if (buffer_options_ == NULL) {
    auto* p = CreateMaybeMessage<::jasper::BufferOptions>(GetArenaNoVirtual());
    buffer_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.buffer_options)
  return buffer_options_;
}
inline void LogOptions::set_allocated_buffer_options(::jasper::BufferOptions* buffer_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete buffer_options_;
  }
  if (buffer_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      buffer_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, buffer_options, submessage_arena);
    }

  } else {

  }
  buffer_options_ = buffer_options;
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.buffer_options)
}

// .jasper.BuildloggerOptions buildlogger_options = 2;
inline bool LogOptions::has_buildlogger_options() const {
  return this != internal_default_instance() && buildlogger_options_ != NULL;
}
inline void LogOptions::clear_buildlogger_options() {
  if (GetArenaNoVirtual() == NULL && buildlogger_options_ != NULL) {
    delete buildlogger_options_;
  }
  buildlogger_options_ = NULL;
}
inline const ::jasper::BuildloggerOptions& LogOptions::_internal_buildlogger_options() const {
  return *buildlogger_options_;
}
inline const ::jasper::BuildloggerOptions& LogOptions::buildlogger_options() const {
  const ::jasper::BuildloggerOptions* p = buildlogger_options_;
  // @@protoc_insertion_point(field_get:jasper.LogOptions.buildlogger_options)
  return p != NULL ? *p : *reinterpret_cast<const ::jasper::BuildloggerOptions*>(
      &::jasper::_BuildloggerOptions_default_instance_);
}
inline ::jasper::BuildloggerOptions* LogOptions::release_buildlogger_options() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.buildlogger_options)

  ::jasper::BuildloggerOptions* temp = buildlogger_options_;
  buildlogger_options_ = NULL;
  return temp;
}
inline ::jasper::BuildloggerOptions* LogOptions::mutable_buildlogger_options() {

  if (buildlogger_options_ == NULL) {
    auto* p = CreateMaybeMessage<::jasper::BuildloggerOptions>(GetArenaNoVirtual());
    buildlogger_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.buildlogger_options)
  return buildlogger_options_;
}
inline void LogOptions::set_allocated_buildlogger_options(::jasper::BuildloggerOptions* buildlogger_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete buildlogger_options_;
  }
  if (buildlogger_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      buildlogger_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, buildlogger_options, submessage_arena);
    }

  } else {

  }
  buildlogger_options_ = buildlogger_options;
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.buildlogger_options)
}

// string default_prefix = 3;
inline void LogOptions::clear_default_prefix() {
  default_prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogOptions::default_prefix() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.default_prefix)
  return default_prefix_.GetNoArena();
}
inline void LogOptions::set_default_prefix(const ::std::string& value) {

  default_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.LogOptions.default_prefix)
}
#if LANG_CXX11
inline void LogOptions::set_default_prefix(::std::string&& value) {

  default_prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.LogOptions.default_prefix)
}
#endif
inline void LogOptions::set_default_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  default_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.LogOptions.default_prefix)
}
inline void LogOptions::set_default_prefix(const char* value, size_t size) {

  default_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.LogOptions.default_prefix)
}
inline ::std::string* LogOptions::mutable_default_prefix() {

  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.default_prefix)
  return default_prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogOptions::release_default_prefix() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.default_prefix)

  return default_prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOptions::set_allocated_default_prefix(::std::string* default_prefix) {
  if (default_prefix != NULL) {

  } else {

  }
  default_prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), default_prefix);
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.default_prefix)
}

// string file_name = 4;
inline void LogOptions::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogOptions::file_name() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.file_name)
  return file_name_.GetNoArena();
}
inline void LogOptions::set_file_name(const ::std::string& value) {

  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.LogOptions.file_name)
}
#if LANG_CXX11
inline void LogOptions::set_file_name(::std::string&& value) {

  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.LogOptions.file_name)
}
#endif
inline void LogOptions::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.LogOptions.file_name)
}
inline void LogOptions::set_file_name(const char* value, size_t size) {

  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.LogOptions.file_name)
}
inline ::std::string* LogOptions::mutable_file_name() {

  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogOptions::release_file_name() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.file_name)

  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOptions::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {

  } else {

  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.file_name)
}

// string format = 5;
inline void LogOptions::clear_format() {
  format_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogOptions::format() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.format)
  return format_.GetNoArena();
}
inline void LogOptions::set_format(const ::std::string& value) {

  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.LogOptions.format)
}
#if LANG_CXX11
inline void LogOptions::set_format(::std::string&& value) {

  format_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.LogOptions.format)
}
#endif
inline void LogOptions::set_format(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.LogOptions.format)
}
inline void LogOptions::set_format(const char* value, size_t size) {

  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.LogOptions.format)
}
inline ::std::string* LogOptions::mutable_format() {

  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.format)
  return format_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogOptions::release_format() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.format)

  return format_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOptions::set_allocated_format(::std::string* format) {
  if (format != NULL) {

  } else {

  }
  format_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.format)
}

// int64 in_memory_cap = 6;
inline void LogOptions::clear_in_memory_cap() {
  in_memory_cap_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LogOptions::in_memory_cap() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.in_memory_cap)
  return in_memory_cap_;
}
inline void LogOptions::set_in_memory_cap(::google::protobuf::int64 value) {

  in_memory_cap_ = value;
  // @@protoc_insertion_point(field_set:jasper.LogOptions.in_memory_cap)
}

// .jasper.SplunkOptions splunk_options = 7;
inline bool LogOptions::has_splunk_options() const {
  return this != internal_default_instance() && splunk_options_ != NULL;
}
inline void LogOptions::clear_splunk_options() {
  if (GetArenaNoVirtual() == NULL && splunk_options_ != NULL) {
    delete splunk_options_;
  }
  splunk_options_ = NULL;
}
inline const ::jasper::SplunkOptions& LogOptions::_internal_splunk_options() const {
  return *splunk_options_;
}
inline const ::jasper::SplunkOptions& LogOptions::splunk_options() const {
  const ::jasper::SplunkOptions* p = splunk_options_;
  // @@protoc_insertion_point(field_get:jasper.LogOptions.splunk_options)
  return p != NULL ? *p : *reinterpret_cast<const ::jasper::SplunkOptions*>(
      &::jasper::_SplunkOptions_default_instance_);
}
inline ::jasper::SplunkOptions* LogOptions::release_splunk_options() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.splunk_options)

  ::jasper::SplunkOptions* temp = splunk_options_;
  splunk_options_ = NULL;
  return temp;
}
inline ::jasper::SplunkOptions* LogOptions::mutable_splunk_options() {

  if (splunk_options_ == NULL) {
    auto* p = CreateMaybeMessage<::jasper::SplunkOptions>(GetArenaNoVirtual());
    splunk_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.splunk_options)
  return splunk_options_;
}
inline void LogOptions::set_allocated_splunk_options(::jasper::SplunkOptions* splunk_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete splunk_options_;
  }
  if (splunk_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      splunk_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, splunk_options, submessage_arena);
    }

  } else {

  }
  splunk_options_ = splunk_options;
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.splunk_options)
}

// string sumo_endpoint = 8;
inline void LogOptions::clear_sumo_endpoint() {
  sumo_endpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogOptions::sumo_endpoint() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.sumo_endpoint)
  return sumo_endpoint_.GetNoArena();
}
inline void LogOptions::set_sumo_endpoint(const ::std::string& value) {

  sumo_endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.LogOptions.sumo_endpoint)
}
#if LANG_CXX11
inline void LogOptions::set_sumo_endpoint(::std::string&& value) {

  sumo_endpoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.LogOptions.sumo_endpoint)
}
#endif
inline void LogOptions::set_sumo_endpoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  sumo_endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.LogOptions.sumo_endpoint)
}
inline void LogOptions::set_sumo_endpoint(const char* value, size_t size) {

  sumo_endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.LogOptions.sumo_endpoint)
}
inline ::std::string* LogOptions::mutable_sumo_endpoint() {

  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.sumo_endpoint)
  return sumo_endpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogOptions::release_sumo_endpoint() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.sumo_endpoint)

  return sumo_endpoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOptions::set_allocated_sumo_endpoint(::std::string* sumo_endpoint) {
  if (sumo_endpoint != NULL) {

  } else {

  }
  sumo_endpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sumo_endpoint);
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.sumo_endpoint)
}

// -------------------------------------------------------------------

// BufferOptions

// bool buffered = 1;
inline void BufferOptions::clear_buffered() {
  buffered_ = false;
}
inline bool BufferOptions::buffered() const {
  // @@protoc_insertion_point(field_get:jasper.BufferOptions.buffered)
  return buffered_;
}
inline void BufferOptions::set_buffered(bool value) {

  buffered_ = value;
  // @@protoc_insertion_point(field_set:jasper.BufferOptions.buffered)
}

// int64 duration = 2;
inline void BufferOptions::clear_duration() {
  duration_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BufferOptions::duration() const {
  // @@protoc_insertion_point(field_get:jasper.BufferOptions.duration)
  return duration_;
}
inline void BufferOptions::set_duration(::google::protobuf::int64 value) {

  duration_ = value;
  // @@protoc_insertion_point(field_set:jasper.BufferOptions.duration)
}

// int64 max_size = 3;
inline void BufferOptions::clear_max_size() {
  max_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BufferOptions::max_size() const {
  // @@protoc_insertion_point(field_get:jasper.BufferOptions.max_size)
  return max_size_;
}
inline void BufferOptions::set_max_size(::google::protobuf::int64 value) {

  max_size_ = value;
  // @@protoc_insertion_point(field_set:jasper.BufferOptions.max_size)
}

// -------------------------------------------------------------------

// BuildloggerOptions

// bool create_test = 1;
inline void BuildloggerOptions::clear_create_test() {
  create_test_ = false;
}
inline bool BuildloggerOptions::create_test() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.create_test)
  return create_test_;
}
inline void BuildloggerOptions::set_create_test(bool value) {

  create_test_ = value;
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.create_test)
}

// string url = 2;
inline void BuildloggerOptions::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildloggerOptions::url() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.url)
  return url_.GetNoArena();
}
inline void BuildloggerOptions::set_url(const ::std::string& value) {

  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.url)
}
#if LANG_CXX11
inline void BuildloggerOptions::set_url(::std::string&& value) {

  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildloggerOptions.url)
}
#endif
inline void BuildloggerOptions::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerOptions.url)
}
inline void BuildloggerOptions::set_url(const char* value, size_t size) {

  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerOptions.url)
}
inline ::std::string* BuildloggerOptions::mutable_url() {

  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerOptions.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildloggerOptions::release_url() {
  // @@protoc_insertion_point(field_release:jasper.BuildloggerOptions.url)

  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildloggerOptions::set_allocated_url(::std::string* url) {
  if (url != NULL) {

  } else {

  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildloggerOptions.url)
}

// int64 number = 3;
inline void BuildloggerOptions::clear_number() {
  number_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BuildloggerOptions::number() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.number)
  return number_;
}
inline void BuildloggerOptions::set_number(::google::protobuf::int64 value) {

  number_ = value;
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.number)
}

// string phase = 4;
inline void BuildloggerOptions::clear_phase() {
  phase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildloggerOptions::phase() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.phase)
  return phase_.GetNoArena();
}
inline void BuildloggerOptions::set_phase(const ::std::string& value) {

  phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.phase)
}
#if LANG_CXX11
inline void BuildloggerOptions::set_phase(::std::string&& value) {

  phase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildloggerOptions.phase)
}
#endif
inline void BuildloggerOptions::set_phase(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerOptions.phase)
}
inline void BuildloggerOptions::set_phase(const char* value, size_t size) {

  phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerOptions.phase)
}
inline ::std::string* BuildloggerOptions::mutable_phase() {

  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerOptions.phase)
  return phase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildloggerOptions::release_phase() {
  // @@protoc_insertion_point(field_release:jasper.BuildloggerOptions.phase)

  return phase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildloggerOptions::set_allocated_phase(::std::string* phase) {
  if (phase != NULL) {

  } else {

  }
  phase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phase);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildloggerOptions.phase)
}

// string builder = 5;
inline void BuildloggerOptions::clear_builder() {
  builder_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildloggerOptions::builder() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.builder)
  return builder_.GetNoArena();
}
inline void BuildloggerOptions::set_builder(const ::std::string& value) {

  builder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.builder)
}
#if LANG_CXX11
inline void BuildloggerOptions::set_builder(::std::string&& value) {

  builder_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildloggerOptions.builder)
}
#endif
inline void BuildloggerOptions::set_builder(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  builder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerOptions.builder)
}
inline void BuildloggerOptions::set_builder(const char* value, size_t size) {

  builder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerOptions.builder)
}
inline ::std::string* BuildloggerOptions::mutable_builder() {

  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerOptions.builder)
  return builder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildloggerOptions::release_builder() {
  // @@protoc_insertion_point(field_release:jasper.BuildloggerOptions.builder)

  return builder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildloggerOptions::set_allocated_builder(::std::string* builder) {
  if (builder != NULL) {

  } else {

  }
  builder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), builder);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildloggerOptions.builder)
}

// string test = 6;
inline void BuildloggerOptions::clear_test() {
  test_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildloggerOptions::test() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.test)
  return test_.GetNoArena();
}
inline void BuildloggerOptions::set_test(const ::std::string& value) {

  test_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.test)
}
#if LANG_CXX11
inline void BuildloggerOptions::set_test(::std::string&& value) {

  test_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildloggerOptions.test)
}
#endif
inline void BuildloggerOptions::set_test(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  test_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerOptions.test)
}
inline void BuildloggerOptions::set_test(const char* value, size_t size) {

  test_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerOptions.test)
}
inline ::std::string* BuildloggerOptions::mutable_test() {

  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerOptions.test)
  return test_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildloggerOptions::release_test() {
  // @@protoc_insertion_point(field_release:jasper.BuildloggerOptions.test)

  return test_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildloggerOptions::set_allocated_test(::std::string* test) {
  if (test != NULL) {

  } else {

  }
  test_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), test);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildloggerOptions.test)
}

// string command = 7;
inline void BuildloggerOptions::clear_command() {
  command_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildloggerOptions::command() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.command)
  return command_.GetNoArena();
}
inline void BuildloggerOptions::set_command(const ::std::string& value) {

  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.command)
}
#if LANG_CXX11
inline void BuildloggerOptions::set_command(::std::string&& value) {

  command_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildloggerOptions.command)
}
#endif
inline void BuildloggerOptions::set_command(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerOptions.command)
}
inline void BuildloggerOptions::set_command(const char* value, size_t size) {

  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerOptions.command)
}
inline ::std::string* BuildloggerOptions::mutable_command() {

  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerOptions.command)
  return command_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildloggerOptions::release_command() {
  // @@protoc_insertion_point(field_release:jasper.BuildloggerOptions.command)

  return command_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildloggerOptions::set_allocated_command(::std::string* command) {
  if (command != NULL) {

  } else {

  }
  command_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), command);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildloggerOptions.command)
}

// -------------------------------------------------------------------

// SplunkOptions

// string url = 1;
inline void SplunkOptions::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SplunkOptions::url() const {
  // @@protoc_insertion_point(field_get:jasper.SplunkOptions.url)
  return url_.GetNoArena();
}
inline void SplunkOptions::set_url(const ::std::string& value) {

  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.SplunkOptions.url)
}
#if LANG_CXX11
inline void SplunkOptions::set_url(::std::string&& value) {

  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.SplunkOptions.url)
}
#endif
inline void SplunkOptions::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.SplunkOptions.url)
}
inline void SplunkOptions::set_url(const char* value, size_t size) {

  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.SplunkOptions.url)
}
inline ::std::string* SplunkOptions::mutable_url() {

  // @@protoc_insertion_point(field_mutable:jasper.SplunkOptions.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SplunkOptions::release_url() {
  // @@protoc_insertion_point(field_release:jasper.SplunkOptions.url)

  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SplunkOptions::set_allocated_url(::std::string* url) {
  if (url != NULL) {

  } else {

  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:jasper.SplunkOptions.url)
}

// string token = 2;
inline void SplunkOptions::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SplunkOptions::token() const {
  // @@protoc_insertion_point(field_get:jasper.SplunkOptions.token)
  return token_.GetNoArena();
}
inline void SplunkOptions::set_token(const ::std::string& value) {

  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.SplunkOptions.token)
}
#if LANG_CXX11
inline void SplunkOptions::set_token(::std::string&& value) {

  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.SplunkOptions.token)
}
#endif
inline void SplunkOptions::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.SplunkOptions.token)
}
inline void SplunkOptions::set_token(const char* value, size_t size) {

  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.SplunkOptions.token)
}
inline ::std::string* SplunkOptions::mutable_token() {

  // @@protoc_insertion_point(field_mutable:jasper.SplunkOptions.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SplunkOptions::release_token() {
  // @@protoc_insertion_point(field_release:jasper.SplunkOptions.token)

  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SplunkOptions::set_allocated_token(::std::string* token) {
  if (token != NULL) {

  } else {

  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:jasper.SplunkOptions.token)
}

// string channel = 3;
inline void SplunkOptions::clear_channel() {
  channel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SplunkOptions::channel() const {
  // @@protoc_insertion_point(field_get:jasper.SplunkOptions.channel)
  return channel_.GetNoArena();
}
inline void SplunkOptions::set_channel(const ::std::string& value) {

  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.SplunkOptions.channel)
}
#if LANG_CXX11
inline void SplunkOptions::set_channel(::std::string&& value) {

  channel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.SplunkOptions.channel)
}
#endif
inline void SplunkOptions::set_channel(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.SplunkOptions.channel)
}
inline void SplunkOptions::set_channel(const char* value, size_t size) {

  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.SplunkOptions.channel)
}
inline ::std::string* SplunkOptions::mutable_channel() {

  // @@protoc_insertion_point(field_mutable:jasper.SplunkOptions.channel)
  return channel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SplunkOptions::release_channel() {
  // @@protoc_insertion_point(field_release:jasper.SplunkOptions.channel)

  return channel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SplunkOptions::set_allocated_channel(::std::string* channel) {
  if (channel != NULL) {

  } else {

  }
  channel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel);
  // @@protoc_insertion_point(field_set_allocated:jasper.SplunkOptions.channel)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateOptions

// repeated string args = 1;
inline int CreateOptions::args_size() const {
  return args_.size();
}
inline void CreateOptions::clear_args() {
  args_.Clear();
}
inline const ::std::string& CreateOptions::args(int index) const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.args)
  return args_.Get(index);
}
inline ::std::string* CreateOptions::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.args)
  return args_.Mutable(index);
}
inline void CreateOptions::set_args(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.args)
  args_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CreateOptions::set_args(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.args)
  args_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CreateOptions::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jasper.CreateOptions.args)
}
inline void CreateOptions::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jasper.CreateOptions.args)
}
inline ::std::string* CreateOptions::add_args() {
  // @@protoc_insertion_point(field_add_mutable:jasper.CreateOptions.args)
  return args_.Add();
}
inline void CreateOptions::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.args)
}
#if LANG_CXX11
inline void CreateOptions::add_args(::std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.args)
}
#endif
inline void CreateOptions::add_args(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jasper.CreateOptions.args)
}
inline void CreateOptions::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jasper.CreateOptions.args)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CreateOptions::args() const {
  // @@protoc_insertion_point(field_list:jasper.CreateOptions.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CreateOptions::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:jasper.CreateOptions.args)
  return &args_;
}

// string working_directory = 2;
inline void CreateOptions::clear_working_directory() {
  working_directory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateOptions::working_directory() const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.working_directory)
  return working_directory_.GetNoArena();
}
inline void CreateOptions::set_working_directory(const ::std::string& value) {

  working_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.working_directory)
}
#if LANG_CXX11
inline void CreateOptions::set_working_directory(::std::string&& value) {

  working_directory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.CreateOptions.working_directory)
}
#endif
inline void CreateOptions::set_working_directory(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  working_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.CreateOptions.working_directory)
}
inline void CreateOptions::set_working_directory(const char* value, size_t size) {

  working_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.CreateOptions.working_directory)
}
inline ::std::string* CreateOptions::mutable_working_directory() {

  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.working_directory)
  return working_directory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateOptions::release_working_directory() {
  // @@protoc_insertion_point(field_release:jasper.CreateOptions.working_directory)

  return working_directory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateOptions::set_allocated_working_directory(::std::string* working_directory) {
  if (working_directory != NULL) {

  } else {

  }
  working_directory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), working_directory);
  // @@protoc_insertion_point(field_set_allocated:jasper.CreateOptions.working_directory)
}

// map<string, string> environment = 3;
inline int CreateOptions::environment_size() const {
  return environment_.size();
}
inline void CreateOptions::clear_environment() {
  environment_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
CreateOptions::environment() const {
  // @@protoc_insertion_point(field_map:jasper.CreateOptions.environment)
  return environment_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
CreateOptions::mutable_environment() {
  // @@protoc_insertion_point(field_mutable_map:jasper.CreateOptions.environment)
  return environment_.MutableMap();
}

// bool override_environ = 4;
inline void CreateOptions::clear_override_environ() {
  override_environ_ = false;
}
inline bool CreateOptions::override_environ() const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.override_environ)
  return override_environ_;
}
inline void CreateOptions::set_override_environ(bool value) {

  override_environ_ = value;
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.override_environ)
}

// int64 timeout_seconds = 5;
inline void CreateOptions::clear_timeout_seconds() {
  timeout_seconds_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreateOptions::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.timeout_seconds)
  return timeout_seconds_;
}
inline void CreateOptions::set_timeout_seconds(::google::protobuf::int64 value) {

  timeout_seconds_ = value;
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.timeout_seconds)
}

// repeated string tags = 6;
inline int CreateOptions::tags_size() const {
  return tags_.size();
}
inline void CreateOptions::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& CreateOptions::tags(int index) const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.tags)
  return tags_.Get(index);
}
inline ::std::string* CreateOptions::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.tags)
  return tags_.Mutable(index);
}
inline void CreateOptions::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CreateOptions::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CreateOptions::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jasper.CreateOptions.tags)
}
inline void CreateOptions::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jasper.CreateOptions.tags)
}
inline ::std::string* CreateOptions::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:jasper.CreateOptions.tags)
  return tags_.Add();
}
inline void CreateOptions::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.tags)
}
#if LANG_CXX11
inline void CreateOptions::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.tags)
}
#endif
inline void CreateOptions::add_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jasper.CreateOptions.tags)
}
inline void CreateOptions::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jasper.CreateOptions.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CreateOptions::tags() const {
  // @@protoc_insertion_point(field_list:jasper.CreateOptions.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CreateOptions::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:jasper.CreateOptions.tags)
  return &tags_;
}

// repeated .jasper.CreateOptions on_success = 7;
inline int CreateOptions::on_success_size() const {
  return on_success_.size();
}
inline void CreateOptions::clear_on_success() {
  on_success_.Clear();
}
inline ::jasper::CreateOptions* CreateOptions::mutable_on_success(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.on_success)
  return on_success_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >*
CreateOptions::mutable_on_success() {
  // @@protoc_insertion_point(field_mutable_list:jasper.CreateOptions.on_success)
  return &on_success_;
}
inline const ::jasper::CreateOptions& CreateOptions::on_success(int index) const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.on_success)
  return on_success_.Get(index);
}
inline ::jasper::CreateOptions* CreateOptions::add_on_success() {
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.on_success)
  return on_success_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >&
CreateOptions::on_success() const {
  // @@protoc_insertion_point(field_list:jasper.CreateOptions.on_success)
  return on_success_;
}

// repeated .jasper.CreateOptions on_failure = 8;
inline int CreateOptions::on_failure_size() const {
  return on_failure_.size();
}
inline void CreateOptions::clear_on_failure() {
  on_failure_.Clear();
}
inline ::jasper::CreateOptions* CreateOptions::mutable_on_failure(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.on_failure)
  return on_failure_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >*
CreateOptions::mutable_on_failure() {
  // @@protoc_insertion_point(field_mutable_list:jasper.CreateOptions.on_failure)
  return &on_failure_;
}
inline const ::jasper::CreateOptions& CreateOptions::on_failure(int index) const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.on_failure)
  return on_failure_.Get(index);
}
inline ::jasper::CreateOptions* CreateOptions::add_on_failure() {
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.on_failure)
  return on_failure_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >&
CreateOptions::on_failure() const {
  // @@protoc_insertion_point(field_list:jasper.CreateOptions.on_failure)
  return on_failure_;
}

// repeated .jasper.CreateOptions on_timeout = 9;
inline int CreateOptions::on_timeout_size() const {
  return on_timeout_.size();
}
inline void CreateOptions::clear_on_timeout() {
  on_timeout_.Clear();
}
inline ::jasper::CreateOptions* CreateOptions::mutable_on_timeout(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.on_timeout)
  return on_timeout_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >*
CreateOptions::mutable_on_timeout() {
  // @@protoc_insertion_point(field_mutable_list:jasper.CreateOptions.on_timeout)
  return &on_timeout_;
}
inline const ::jasper::CreateOptions& CreateOptions::on_timeout(int index) const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.on_timeout)
  return on_timeout_.Get(index);
}
inline ::jasper::CreateOptions* CreateOptions::add_on_timeout() {
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.on_timeout)
  return on_timeout_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jasper::CreateOptions >&
CreateOptions::on_timeout() const {
  // @@protoc_insertion_point(field_list:jasper.CreateOptions.on_timeout)
  return on_timeout_;
}

// .jasper.OutputOptions output = 10;
inline bool CreateOptions::has_output() const {
  return this != internal_default_instance() && output_ != NULL;
}
inline void CreateOptions::clear_output() {
  if (GetArenaNoVirtual() == NULL && output_ != NULL) {
    delete output_;
  }
  output_ = NULL;
}
inline const ::jasper::OutputOptions& CreateOptions::_internal_output() const {
  return *output_;
}
inline const ::jasper::OutputOptions& CreateOptions::output() const {
  const ::jasper::OutputOptions* p = output_;
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.output)
  return p != NULL ? *p : *reinterpret_cast<const ::jasper::OutputOptions*>(
      &::jasper::_OutputOptions_default_instance_);
}
inline ::jasper::OutputOptions* CreateOptions::release_output() {
  // @@protoc_insertion_point(field_release:jasper.CreateOptions.output)

  ::jasper::OutputOptions* temp = output_;
  output_ = NULL;
  return temp;
}
inline ::jasper::OutputOptions* CreateOptions::mutable_output() {

  if (output_ == NULL) {
    auto* p = CreateMaybeMessage<::jasper::OutputOptions>(GetArenaNoVirtual());
    output_ = p;
  }
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.output)
  return output_;
}
inline void CreateOptions::set_allocated_output(::jasper::OutputOptions* output) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete output_;
  }
  if (output) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      output = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }

  } else {

  }
  output_ = output;
  // @@protoc_insertion_point(field_set_allocated:jasper.CreateOptions.output)
}

// -------------------------------------------------------------------

// ProcessInfo

// string id = 1;
inline void ProcessInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcessInfo::id() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.id)
  return id_.GetNoArena();
}
inline void ProcessInfo::set_id(const ::std::string& value) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.id)
}
#if LANG_CXX11
inline void ProcessInfo::set_id(::std::string&& value) {

  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.ProcessInfo.id)
}
#endif
inline void ProcessInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.ProcessInfo.id)
}
inline void ProcessInfo::set_id(const char* value, size_t size) {

  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.ProcessInfo.id)
}
inline ::std::string* ProcessInfo::mutable_id() {

  // @@protoc_insertion_point(field_mutable:jasper.ProcessInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessInfo::release_id() {
  // @@protoc_insertion_point(field_release:jasper.ProcessInfo.id)

  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {

  } else {

  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:jasper.ProcessInfo.id)
}

// int64 pid = 2;
inline void ProcessInfo::clear_pid() {
  pid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ProcessInfo::pid() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.pid)
  return pid_;
}
inline void ProcessInfo::set_pid(::google::protobuf::int64 value) {

  pid_ = value;
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.pid)
}

// string host_id = 3;
inline void ProcessInfo::clear_host_id() {
  host_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcessInfo::host_id() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.host_id)
  return host_id_.GetNoArena();
}
inline void ProcessInfo::set_host_id(const ::std::string& value) {

  host_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.host_id)
}
#if LANG_CXX11
inline void ProcessInfo::set_host_id(::std::string&& value) {

  host_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.ProcessInfo.host_id)
}
#endif
inline void ProcessInfo::set_host_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  host_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.ProcessInfo.host_id)
}
inline void ProcessInfo::set_host_id(const char* value, size_t size) {

  host_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.ProcessInfo.host_id)
}
inline ::std::string* ProcessInfo::mutable_host_id() {

  // @@protoc_insertion_point(field_mutable:jasper.ProcessInfo.host_id)
  return host_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessInfo::release_host_id() {
  // @@protoc_insertion_point(field_release:jasper.ProcessInfo.host_id)

  return host_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessInfo::set_allocated_host_id(::std::string* host_id) {
  if (host_id != NULL) {

  } else {

  }
  host_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_id);
  // @@protoc_insertion_point(field_set_allocated:jasper.ProcessInfo.host_id)
}

// bool running = 4;
inline void ProcessInfo::clear_running() {
  running_ = false;
}
inline bool ProcessInfo::running() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.running)
  return running_;
}
inline void ProcessInfo::set_running(bool value) {

  running_ = value;
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.running)
}

// bool successful = 5;
inline void ProcessInfo::clear_successful() {
  successful_ = false;
}
inline bool ProcessInfo::successful() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.successful)
  return successful_;
}
inline void ProcessInfo::set_successful(bool value) {

  successful_ = value;
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.successful)
}

// bool complete = 6;
inline void ProcessInfo::clear_complete() {
  complete_ = false;
}
inline bool ProcessInfo::complete() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.complete)
  return complete_;
}
inline void ProcessInfo::set_complete(bool value) {

  complete_ = value;
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.complete)
}

// bool timedout = 7;
inline void ProcessInfo::clear_timedout() {
  timedout_ = false;
}
inline bool ProcessInfo::timedout() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.timedout)
  return timedout_;
}
inline void ProcessInfo::set_timedout(bool value) {

  timedout_ = value;
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.timedout)
}

// .jasper.CreateOptions options = 8;
inline bool ProcessInfo::has_options() const {
  return this != internal_default_instance() && options_ != NULL;
}
inline void ProcessInfo::clear_options() {
  if (GetArenaNoVirtual() == NULL && options_ != NULL) {
    delete options_;
  }
  options_ = NULL;
}
inline const ::jasper::CreateOptions& ProcessInfo::_internal_options() const {
  return *options_;
}
inline const ::jasper::CreateOptions& ProcessInfo::options() const {
  const ::jasper::CreateOptions* p = options_;
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.options)
  return p != NULL ? *p : *reinterpret_cast<const ::jasper::CreateOptions*>(
      &::jasper::_CreateOptions_default_instance_);
}
inline ::jasper::CreateOptions* ProcessInfo::release_options() {
  // @@protoc_insertion_point(field_release:jasper.ProcessInfo.options)

  ::jasper::CreateOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::jasper::CreateOptions* ProcessInfo::mutable_options() {

  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::jasper::CreateOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:jasper.ProcessInfo.options)
  return options_;
}
inline void ProcessInfo::set_allocated_options(::jasper::CreateOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }

  } else {

  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:jasper.ProcessInfo.options)
}

// -------------------------------------------------------------------

// StatusResponse

// string host_id = 1;
inline void StatusResponse::clear_host_id() {
  host_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusResponse::host_id() const {
  // @@protoc_insertion_point(field_get:jasper.StatusResponse.host_id)
  return host_id_.GetNoArena();
}
inline void StatusResponse::set_host_id(const ::std::string& value) {

  host_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.StatusResponse.host_id)
}
#if LANG_CXX11
inline void StatusResponse::set_host_id(::std::string&& value) {

  host_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.StatusResponse.host_id)
}
#endif
inline void StatusResponse::set_host_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  host_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.StatusResponse.host_id)
}
inline void StatusResponse::set_host_id(const char* value, size_t size) {

  host_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.StatusResponse.host_id)
}
inline ::std::string* StatusResponse::mutable_host_id() {

  // @@protoc_insertion_point(field_mutable:jasper.StatusResponse.host_id)
  return host_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusResponse::release_host_id() {
  // @@protoc_insertion_point(field_release:jasper.StatusResponse.host_id)

  return host_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_host_id(::std::string* host_id) {
  if (host_id != NULL) {

  } else {

  }
  host_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_id);
  // @@protoc_insertion_point(field_set_allocated:jasper.StatusResponse.host_id)
}

// bool active = 2;
inline void StatusResponse::clear_active() {
  active_ = false;
}
inline bool StatusResponse::active() const {
  // @@protoc_insertion_point(field_get:jasper.StatusResponse.active)
  return active_;
}
inline void StatusResponse::set_active(bool value) {

  active_ = value;
  // @@protoc_insertion_point(field_set:jasper.StatusResponse.active)
}

// -------------------------------------------------------------------

// Filter

// .jasper.FilterSpecifications name = 1;
inline void Filter::clear_name() {
  name_ = 0;
}
inline ::jasper::FilterSpecifications Filter::name() const {
  // @@protoc_insertion_point(field_get:jasper.Filter.name)
  return static_cast< ::jasper::FilterSpecifications >(name_);
}
inline void Filter::set_name(::jasper::FilterSpecifications value) {

  name_ = value;
  // @@protoc_insertion_point(field_set:jasper.Filter.name)
}

// -------------------------------------------------------------------

// SignalProcess

// .jasper.JasperProcessID ProcessID = 1;
inline bool SignalProcess::has_processid() const {
  return this != internal_default_instance() && processid_ != NULL;
}
inline void SignalProcess::clear_processid() {
  if (GetArenaNoVirtual() == NULL && processid_ != NULL) {
    delete processid_;
  }
  processid_ = NULL;
}
inline const ::jasper::JasperProcessID& SignalProcess::_internal_processid() const {
  return *processid_;
}
inline const ::jasper::JasperProcessID& SignalProcess::processid() const {
  const ::jasper::JasperProcessID* p = processid_;
  // @@protoc_insertion_point(field_get:jasper.SignalProcess.ProcessID)
  return p != NULL ? *p : *reinterpret_cast<const ::jasper::JasperProcessID*>(
      &::jasper::_JasperProcessID_default_instance_);
}
inline ::jasper::JasperProcessID* SignalProcess::release_processid() {
  // @@protoc_insertion_point(field_release:jasper.SignalProcess.ProcessID)

  ::jasper::JasperProcessID* temp = processid_;
  processid_ = NULL;
  return temp;
}
inline ::jasper::JasperProcessID* SignalProcess::mutable_processid() {

  if (processid_ == NULL) {
    auto* p = CreateMaybeMessage<::jasper::JasperProcessID>(GetArenaNoVirtual());
    processid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:jasper.SignalProcess.ProcessID)
  return processid_;
}
inline void SignalProcess::set_allocated_processid(::jasper::JasperProcessID* processid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete processid_;
  }
  if (processid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      processid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, processid, submessage_arena);
    }

  } else {

  }
  processid_ = processid;
  // @@protoc_insertion_point(field_set_allocated:jasper.SignalProcess.ProcessID)
}

// .jasper.Signals signal = 2;
inline void SignalProcess::clear_signal() {
  signal_ = 0;
}
inline ::jasper::Signals SignalProcess::signal() const {
  // @@protoc_insertion_point(field_get:jasper.SignalProcess.signal)
  return static_cast< ::jasper::Signals >(signal_);
}
inline void SignalProcess::set_signal(::jasper::Signals value) {

  signal_ = value;
  // @@protoc_insertion_point(field_set:jasper.SignalProcess.signal)
}

// -------------------------------------------------------------------

// TagName

// string value = 1;
inline void TagName::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TagName::value() const {
  // @@protoc_insertion_point(field_get:jasper.TagName.value)
  return value_.GetNoArena();
}
inline void TagName::set_value(const ::std::string& value) {

  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.TagName.value)
}
#if LANG_CXX11
inline void TagName::set_value(::std::string&& value) {

  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.TagName.value)
}
#endif
inline void TagName::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.TagName.value)
}
inline void TagName::set_value(const char* value, size_t size) {

  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.TagName.value)
}
inline ::std::string* TagName::mutable_value() {

  // @@protoc_insertion_point(field_mutable:jasper.TagName.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TagName::release_value() {
  // @@protoc_insertion_point(field_release:jasper.TagName.value)

  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TagName::set_allocated_value(::std::string* value) {
  if (value != NULL) {

  } else {

  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:jasper.TagName.value)
}

// -------------------------------------------------------------------

// ProcessTags

// string processID = 1;
inline void ProcessTags::clear_processid() {
  processid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcessTags::processid() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessTags.processID)
  return processid_.GetNoArena();
}
inline void ProcessTags::set_processid(const ::std::string& value) {

  processid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.ProcessTags.processID)
}
#if LANG_CXX11
inline void ProcessTags::set_processid(::std::string&& value) {

  processid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.ProcessTags.processID)
}
#endif
inline void ProcessTags::set_processid(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  processid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.ProcessTags.processID)
}
inline void ProcessTags::set_processid(const char* value, size_t size) {

  processid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.ProcessTags.processID)
}
inline ::std::string* ProcessTags::mutable_processid() {

  // @@protoc_insertion_point(field_mutable:jasper.ProcessTags.processID)
  return processid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessTags::release_processid() {
  // @@protoc_insertion_point(field_release:jasper.ProcessTags.processID)

  return processid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessTags::set_allocated_processid(::std::string* processid) {
  if (processid != NULL) {

  } else {

  }
  processid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), processid);
  // @@protoc_insertion_point(field_set_allocated:jasper.ProcessTags.processID)
}

// repeated string tags = 2;
inline int ProcessTags::tags_size() const {
  return tags_.size();
}
inline void ProcessTags::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& ProcessTags::tags(int index) const {
  // @@protoc_insertion_point(field_get:jasper.ProcessTags.tags)
  return tags_.Get(index);
}
inline ::std::string* ProcessTags::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.ProcessTags.tags)
  return tags_.Mutable(index);
}
inline void ProcessTags::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jasper.ProcessTags.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ProcessTags::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jasper.ProcessTags.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ProcessTags::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jasper.ProcessTags.tags)
}
inline void ProcessTags::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jasper.ProcessTags.tags)
}
inline ::std::string* ProcessTags::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:jasper.ProcessTags.tags)
  return tags_.Add();
}
inline void ProcessTags::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jasper.ProcessTags.tags)
}
#if LANG_CXX11
inline void ProcessTags::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jasper.ProcessTags.tags)
}
#endif
inline void ProcessTags::add_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jasper.ProcessTags.tags)
}
inline void ProcessTags::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jasper.ProcessTags.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProcessTags::tags() const {
  // @@protoc_insertion_point(field_list:jasper.ProcessTags.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProcessTags::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:jasper.ProcessTags.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// JasperProcessID

// string value = 1;
inline void JasperProcessID::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JasperProcessID::value() const {
  // @@protoc_insertion_point(field_get:jasper.JasperProcessID.value)
  return value_.GetNoArena();
}
inline void JasperProcessID::set_value(const ::std::string& value) {

  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.JasperProcessID.value)
}
#if LANG_CXX11
inline void JasperProcessID::set_value(::std::string&& value) {

  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.JasperProcessID.value)
}
#endif
inline void JasperProcessID::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.JasperProcessID.value)
}
inline void JasperProcessID::set_value(const char* value, size_t size) {

  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.JasperProcessID.value)
}
inline ::std::string* JasperProcessID::mutable_value() {

  // @@protoc_insertion_point(field_mutable:jasper.JasperProcessID.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JasperProcessID::release_value() {
  // @@protoc_insertion_point(field_release:jasper.JasperProcessID.value)

  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JasperProcessID::set_allocated_value(::std::string* value) {
  if (value != NULL) {

  } else {

  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:jasper.JasperProcessID.value)
}

// -------------------------------------------------------------------

// OperationOutcome

// bool success = 1;
inline void OperationOutcome::clear_success() {
  success_ = false;
}
inline bool OperationOutcome::success() const {
  // @@protoc_insertion_point(field_get:jasper.OperationOutcome.success)
  return success_;
}
inline void OperationOutcome::set_success(bool value) {

  success_ = value;
  // @@protoc_insertion_point(field_set:jasper.OperationOutcome.success)
}

// string text = 2;
inline void OperationOutcome::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationOutcome::text() const {
  // @@protoc_insertion_point(field_get:jasper.OperationOutcome.text)
  return text_.GetNoArena();
}
inline void OperationOutcome::set_text(const ::std::string& value) {

  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.OperationOutcome.text)
}
#if LANG_CXX11
inline void OperationOutcome::set_text(::std::string&& value) {

  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.OperationOutcome.text)
}
#endif
inline void OperationOutcome::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.OperationOutcome.text)
}
inline void OperationOutcome::set_text(const char* value, size_t size) {

  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.OperationOutcome.text)
}
inline ::std::string* OperationOutcome::mutable_text() {

  // @@protoc_insertion_point(field_mutable:jasper.OperationOutcome.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationOutcome::release_text() {
  // @@protoc_insertion_point(field_release:jasper.OperationOutcome.text)

  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationOutcome::set_allocated_text(::std::string* text) {
  if (text != NULL) {

  } else {

  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:jasper.OperationOutcome.text)
}

// -------------------------------------------------------------------

// BuildOptions

// string target = 1;
inline void BuildOptions::clear_target() {
  target_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildOptions::target() const {
  // @@protoc_insertion_point(field_get:jasper.BuildOptions.target)
  return target_.GetNoArena();
}
inline void BuildOptions::set_target(const ::std::string& value) {

  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.BuildOptions.target)
}
#if LANG_CXX11
inline void BuildOptions::set_target(::std::string&& value) {

  target_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildOptions.target)
}
#endif
inline void BuildOptions::set_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildOptions.target)
}
inline void BuildOptions::set_target(const char* value, size_t size) {

  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildOptions.target)
}
inline ::std::string* BuildOptions::mutable_target() {

  // @@protoc_insertion_point(field_mutable:jasper.BuildOptions.target)
  return target_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildOptions::release_target() {
  // @@protoc_insertion_point(field_release:jasper.BuildOptions.target)

  return target_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildOptions::set_allocated_target(::std::string* target) {
  if (target != NULL) {

  } else {

  }
  target_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildOptions.target)
}

// string arch = 2;
inline void BuildOptions::clear_arch() {
  arch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildOptions::arch() const {
  // @@protoc_insertion_point(field_get:jasper.BuildOptions.arch)
  return arch_.GetNoArena();
}
inline void BuildOptions::set_arch(const ::std::string& value) {

  arch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.BuildOptions.arch)
}
#if LANG_CXX11
inline void BuildOptions::set_arch(::std::string&& value) {

  arch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildOptions.arch)
}
#endif
inline void BuildOptions::set_arch(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  arch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildOptions.arch)
}
inline void BuildOptions::set_arch(const char* value, size_t size) {

  arch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildOptions.arch)
}
inline ::std::string* BuildOptions::mutable_arch() {

  // @@protoc_insertion_point(field_mutable:jasper.BuildOptions.arch)
  return arch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildOptions::release_arch() {
  // @@protoc_insertion_point(field_release:jasper.BuildOptions.arch)

  return arch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildOptions::set_allocated_arch(::std::string* arch) {
  if (arch != NULL) {

  } else {

  }
  arch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), arch);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildOptions.arch)
}

// string edition = 3;
inline void BuildOptions::clear_edition() {
  edition_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildOptions::edition() const {
  // @@protoc_insertion_point(field_get:jasper.BuildOptions.edition)
  return edition_.GetNoArena();
}
inline void BuildOptions::set_edition(const ::std::string& value) {

  edition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.BuildOptions.edition)
}
#if LANG_CXX11
inline void BuildOptions::set_edition(::std::string&& value) {

  edition_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildOptions.edition)
}
#endif
inline void BuildOptions::set_edition(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  edition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildOptions.edition)
}
inline void BuildOptions::set_edition(const char* value, size_t size) {

  edition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildOptions.edition)
}
inline ::std::string* BuildOptions::mutable_edition() {

  // @@protoc_insertion_point(field_mutable:jasper.BuildOptions.edition)
  return edition_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildOptions::release_edition() {
  // @@protoc_insertion_point(field_release:jasper.BuildOptions.edition)

  return edition_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildOptions::set_allocated_edition(::std::string* edition) {
  if (edition != NULL) {

  } else {

  }
  edition_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), edition);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildOptions.edition)
}

// bool debug = 4;
inline void BuildOptions::clear_debug() {
  debug_ = false;
}
inline bool BuildOptions::debug() const {
  // @@protoc_insertion_point(field_get:jasper.BuildOptions.debug)
  return debug_;
}
inline void BuildOptions::set_debug(bool value) {

  debug_ = value;
  // @@protoc_insertion_point(field_set:jasper.BuildOptions.debug)
}

// -------------------------------------------------------------------

// MongoDBDownloadOptions

// .jasper.BuildOptions build_options = 1;
inline bool MongoDBDownloadOptions::has_build_options() const {
  return this != internal_default_instance() && build_options_ != NULL;
}
inline void MongoDBDownloadOptions::clear_build_options() {
  if (GetArenaNoVirtual() == NULL && build_options_ != NULL) {
    delete build_options_;
  }
  build_options_ = NULL;
}
inline const ::jasper::BuildOptions& MongoDBDownloadOptions::_internal_build_options() const {
  return *build_options_;
}
inline const ::jasper::BuildOptions& MongoDBDownloadOptions::build_options() const {
  const ::jasper::BuildOptions* p = build_options_;
  // @@protoc_insertion_point(field_get:jasper.MongoDBDownloadOptions.build_options)
  return p != NULL ? *p : *reinterpret_cast<const ::jasper::BuildOptions*>(
      &::jasper::_BuildOptions_default_instance_);
}
inline ::jasper::BuildOptions* MongoDBDownloadOptions::release_build_options() {
  // @@protoc_insertion_point(field_release:jasper.MongoDBDownloadOptions.build_options)

  ::jasper::BuildOptions* temp = build_options_;
  build_options_ = NULL;
  return temp;
}
inline ::jasper::BuildOptions* MongoDBDownloadOptions::mutable_build_options() {

  if (build_options_ == NULL) {
    auto* p = CreateMaybeMessage<::jasper::BuildOptions>(GetArenaNoVirtual());
    build_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:jasper.MongoDBDownloadOptions.build_options)
  return build_options_;
}
inline void MongoDBDownloadOptions::set_allocated_build_options(::jasper::BuildOptions* build_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete build_options_;
  }
  if (build_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      build_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, build_options, submessage_arena);
    }

  } else {

  }
  build_options_ = build_options;
  // @@protoc_insertion_point(field_set_allocated:jasper.MongoDBDownloadOptions.build_options)
}

// string path = 2;
inline void MongoDBDownloadOptions::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MongoDBDownloadOptions::path() const {
  // @@protoc_insertion_point(field_get:jasper.MongoDBDownloadOptions.path)
  return path_.GetNoArena();
}
inline void MongoDBDownloadOptions::set_path(const ::std::string& value) {

  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.MongoDBDownloadOptions.path)
}
#if LANG_CXX11
inline void MongoDBDownloadOptions::set_path(::std::string&& value) {

  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.MongoDBDownloadOptions.path)
}
#endif
inline void MongoDBDownloadOptions::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.MongoDBDownloadOptions.path)
}
inline void MongoDBDownloadOptions::set_path(const char* value, size_t size) {

  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.MongoDBDownloadOptions.path)
}
inline ::std::string* MongoDBDownloadOptions::mutable_path() {

  // @@protoc_insertion_point(field_mutable:jasper.MongoDBDownloadOptions.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MongoDBDownloadOptions::release_path() {
  // @@protoc_insertion_point(field_release:jasper.MongoDBDownloadOptions.path)

  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MongoDBDownloadOptions::set_allocated_path(::std::string* path) {
  if (path != NULL) {

  } else {

  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:jasper.MongoDBDownloadOptions.path)
}

// repeated string releases = 3;
inline int MongoDBDownloadOptions::releases_size() const {
  return releases_.size();
}
inline void MongoDBDownloadOptions::clear_releases() {
  releases_.Clear();
}
inline const ::std::string& MongoDBDownloadOptions::releases(int index) const {
  // @@protoc_insertion_point(field_get:jasper.MongoDBDownloadOptions.releases)
  return releases_.Get(index);
}
inline ::std::string* MongoDBDownloadOptions::mutable_releases(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.MongoDBDownloadOptions.releases)
  return releases_.Mutable(index);
}
inline void MongoDBDownloadOptions::set_releases(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jasper.MongoDBDownloadOptions.releases)
  releases_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MongoDBDownloadOptions::set_releases(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jasper.MongoDBDownloadOptions.releases)
  releases_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MongoDBDownloadOptions::set_releases(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  releases_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jasper.MongoDBDownloadOptions.releases)
}
inline void MongoDBDownloadOptions::set_releases(int index, const char* value, size_t size) {
  releases_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jasper.MongoDBDownloadOptions.releases)
}
inline ::std::string* MongoDBDownloadOptions::add_releases() {
  // @@protoc_insertion_point(field_add_mutable:jasper.MongoDBDownloadOptions.releases)
  return releases_.Add();
}
inline void MongoDBDownloadOptions::add_releases(const ::std::string& value) {
  releases_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jasper.MongoDBDownloadOptions.releases)
}
#if LANG_CXX11
inline void MongoDBDownloadOptions::add_releases(::std::string&& value) {
  releases_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jasper.MongoDBDownloadOptions.releases)
}
#endif
inline void MongoDBDownloadOptions::add_releases(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  releases_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jasper.MongoDBDownloadOptions.releases)
}
inline void MongoDBDownloadOptions::add_releases(const char* value, size_t size) {
  releases_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jasper.MongoDBDownloadOptions.releases)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MongoDBDownloadOptions::releases() const {
  // @@protoc_insertion_point(field_list:jasper.MongoDBDownloadOptions.releases)
  return releases_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MongoDBDownloadOptions::mutable_releases() {
  // @@protoc_insertion_point(field_mutable_list:jasper.MongoDBDownloadOptions.releases)
  return &releases_;
}

// -------------------------------------------------------------------

// CacheOptions

// bool disabled = 1;
inline void CacheOptions::clear_disabled() {
  disabled_ = false;
}
inline bool CacheOptions::disabled() const {
  // @@protoc_insertion_point(field_get:jasper.CacheOptions.disabled)
  return disabled_;
}
inline void CacheOptions::set_disabled(bool value) {

  disabled_ = value;
  // @@protoc_insertion_point(field_set:jasper.CacheOptions.disabled)
}

// int64 prune_delay = 2;
inline void CacheOptions::clear_prune_delay() {
  prune_delay_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CacheOptions::prune_delay() const {
  // @@protoc_insertion_point(field_get:jasper.CacheOptions.prune_delay)
  return prune_delay_;
}
inline void CacheOptions::set_prune_delay(::google::protobuf::int64 value) {

  prune_delay_ = value;
  // @@protoc_insertion_point(field_set:jasper.CacheOptions.prune_delay)
}

// int64 max_size = 3;
inline void CacheOptions::clear_max_size() {
  max_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CacheOptions::max_size() const {
  // @@protoc_insertion_point(field_get:jasper.CacheOptions.max_size)
  return max_size_;
}
inline void CacheOptions::set_max_size(::google::protobuf::int64 value) {

  max_size_ = value;
  // @@protoc_insertion_point(field_set:jasper.CacheOptions.max_size)
}

// -------------------------------------------------------------------

// ArchiveOptions

// bool should_extract = 1;
inline void ArchiveOptions::clear_should_extract() {
  should_extract_ = false;
}
inline bool ArchiveOptions::should_extract() const {
  // @@protoc_insertion_point(field_get:jasper.ArchiveOptions.should_extract)
  return should_extract_;
}
inline void ArchiveOptions::set_should_extract(bool value) {

  should_extract_ = value;
  // @@protoc_insertion_point(field_set:jasper.ArchiveOptions.should_extract)
}

// .jasper.ArchiveFormat format = 2;
inline void ArchiveOptions::clear_format() {
  format_ = 0;
}
inline ::jasper::ArchiveFormat ArchiveOptions::format() const {
  // @@protoc_insertion_point(field_get:jasper.ArchiveOptions.format)
  return static_cast< ::jasper::ArchiveFormat >(format_);
}
inline void ArchiveOptions::set_format(::jasper::ArchiveFormat value) {

  format_ = value;
  // @@protoc_insertion_point(field_set:jasper.ArchiveOptions.format)
}

// string target_path = 3;
inline void ArchiveOptions::clear_target_path() {
  target_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArchiveOptions::target_path() const {
  // @@protoc_insertion_point(field_get:jasper.ArchiveOptions.target_path)
  return target_path_.GetNoArena();
}
inline void ArchiveOptions::set_target_path(const ::std::string& value) {

  target_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.ArchiveOptions.target_path)
}
#if LANG_CXX11
inline void ArchiveOptions::set_target_path(::std::string&& value) {

  target_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.ArchiveOptions.target_path)
}
#endif
inline void ArchiveOptions::set_target_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  target_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.ArchiveOptions.target_path)
}
inline void ArchiveOptions::set_target_path(const char* value, size_t size) {

  target_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.ArchiveOptions.target_path)
}
inline ::std::string* ArchiveOptions::mutable_target_path() {

  // @@protoc_insertion_point(field_mutable:jasper.ArchiveOptions.target_path)
  return target_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArchiveOptions::release_target_path() {
  // @@protoc_insertion_point(field_release:jasper.ArchiveOptions.target_path)

  return target_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArchiveOptions::set_allocated_target_path(::std::string* target_path) {
  if (target_path != NULL) {

  } else {

  }
  target_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_path);
  // @@protoc_insertion_point(field_set_allocated:jasper.ArchiveOptions.target_path)
}

// -------------------------------------------------------------------

// DownloadInfo

// string url = 1;
inline void DownloadInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DownloadInfo::url() const {
  // @@protoc_insertion_point(field_get:jasper.DownloadInfo.url)
  return url_.GetNoArena();
}
inline void DownloadInfo::set_url(const ::std::string& value) {

  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.DownloadInfo.url)
}
#if LANG_CXX11
inline void DownloadInfo::set_url(::std::string&& value) {

  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.DownloadInfo.url)
}
#endif
inline void DownloadInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.DownloadInfo.url)
}
inline void DownloadInfo::set_url(const char* value, size_t size) {

  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.DownloadInfo.url)
}
inline ::std::string* DownloadInfo::mutable_url() {

  // @@protoc_insertion_point(field_mutable:jasper.DownloadInfo.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DownloadInfo::release_url() {
  // @@protoc_insertion_point(field_release:jasper.DownloadInfo.url)

  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadInfo::set_allocated_url(::std::string* url) {
  if (url != NULL) {

  } else {

  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:jasper.DownloadInfo.url)
}

// string path = 2;
inline void DownloadInfo::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DownloadInfo::path() const {
  // @@protoc_insertion_point(field_get:jasper.DownloadInfo.path)
  return path_.GetNoArena();
}
inline void DownloadInfo::set_path(const ::std::string& value) {

  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jasper.DownloadInfo.path)
}
#if LANG_CXX11
inline void DownloadInfo::set_path(::std::string&& value) {

  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.DownloadInfo.path)
}
#endif
inline void DownloadInfo::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.DownloadInfo.path)
}
inline void DownloadInfo::set_path(const char* value, size_t size) {

  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.DownloadInfo.path)
}
inline ::std::string* DownloadInfo::mutable_path() {

  // @@protoc_insertion_point(field_mutable:jasper.DownloadInfo.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DownloadInfo::release_path() {
  // @@protoc_insertion_point(field_release:jasper.DownloadInfo.path)

  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadInfo::set_allocated_path(::std::string* path) {
  if (path != NULL) {

  } else {

  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:jasper.DownloadInfo.path)
}

// .jasper.ArchiveOptions archive_opts = 3;
inline bool DownloadInfo::has_archive_opts() const {
  return this != internal_default_instance() && archive_opts_ != NULL;
}
inline void DownloadInfo::clear_archive_opts() {
  if (GetArenaNoVirtual() == NULL && archive_opts_ != NULL) {
    delete archive_opts_;
  }
  archive_opts_ = NULL;
}
inline const ::jasper::ArchiveOptions& DownloadInfo::_internal_archive_opts() const {
  return *archive_opts_;
}
inline const ::jasper::ArchiveOptions& DownloadInfo::archive_opts() const {
  const ::jasper::ArchiveOptions* p = archive_opts_;
  // @@protoc_insertion_point(field_get:jasper.DownloadInfo.archive_opts)
  return p != NULL ? *p : *reinterpret_cast<const ::jasper::ArchiveOptions*>(
      &::jasper::_ArchiveOptions_default_instance_);
}
inline ::jasper::ArchiveOptions* DownloadInfo::release_archive_opts() {
  // @@protoc_insertion_point(field_release:jasper.DownloadInfo.archive_opts)

  ::jasper::ArchiveOptions* temp = archive_opts_;
  archive_opts_ = NULL;
  return temp;
}
inline ::jasper::ArchiveOptions* DownloadInfo::mutable_archive_opts() {

  if (archive_opts_ == NULL) {
    auto* p = CreateMaybeMessage<::jasper::ArchiveOptions>(GetArenaNoVirtual());
    archive_opts_ = p;
  }
  // @@protoc_insertion_point(field_mutable:jasper.DownloadInfo.archive_opts)
  return archive_opts_;
}
inline void DownloadInfo::set_allocated_archive_opts(::jasper::ArchiveOptions* archive_opts) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete archive_opts_;
  }
  if (archive_opts) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      archive_opts = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, archive_opts, submessage_arena);
    }

  } else {

  }
  archive_opts_ = archive_opts;
  // @@protoc_insertion_point(field_set_allocated:jasper.DownloadInfo.archive_opts)
}

// -------------------------------------------------------------------

// BuildloggerURLs

// repeated string urls = 1;
inline int BuildloggerURLs::urls_size() const {
  return urls_.size();
}
inline void BuildloggerURLs::clear_urls() {
  urls_.Clear();
}
inline const ::std::string& BuildloggerURLs::urls(int index) const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerURLs.urls)
  return urls_.Get(index);
}
inline ::std::string* BuildloggerURLs::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerURLs.urls)
  return urls_.Mutable(index);
}
inline void BuildloggerURLs::set_urls(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jasper.BuildloggerURLs.urls)
  urls_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BuildloggerURLs::set_urls(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jasper.BuildloggerURLs.urls)
  urls_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BuildloggerURLs::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerURLs.urls)
}
inline void BuildloggerURLs::set_urls(int index, const char* value, size_t size) {
  urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerURLs.urls)
}
inline ::std::string* BuildloggerURLs::add_urls() {
  // @@protoc_insertion_point(field_add_mutable:jasper.BuildloggerURLs.urls)
  return urls_.Add();
}
inline void BuildloggerURLs::add_urls(const ::std::string& value) {
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jasper.BuildloggerURLs.urls)
}
#if LANG_CXX11
inline void BuildloggerURLs::add_urls(::std::string&& value) {
  urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jasper.BuildloggerURLs.urls)
}
#endif
inline void BuildloggerURLs::add_urls(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jasper.BuildloggerURLs.urls)
}
inline void BuildloggerURLs::add_urls(const char* value, size_t size) {
  urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jasper.BuildloggerURLs.urls)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BuildloggerURLs::urls() const {
  // @@protoc_insertion_point(field_list:jasper.BuildloggerURLs.urls)
  return urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BuildloggerURLs::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:jasper.BuildloggerURLs.urls)
  return &urls_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace jasper

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::jasper::LogType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jasper::LogType>() {
  return ::jasper::LogType_descriptor();
}
template <> struct is_proto_enum< ::jasper::LogFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jasper::LogFormat>() {
  return ::jasper::LogFormat_descriptor();
}
template <> struct is_proto_enum< ::jasper::FilterSpecifications> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jasper::FilterSpecifications>() {
  return ::jasper::FilterSpecifications_descriptor();
}
template <> struct is_proto_enum< ::jasper::Signals> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jasper::Signals>() {
  return ::jasper::Signals_descriptor();
}
template <> struct is_proto_enum< ::jasper::ArchiveFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jasper::ArchiveFormat>() {
  return ::jasper::ArchiveFormat_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_jasper_2eproto
