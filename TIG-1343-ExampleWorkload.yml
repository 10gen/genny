---
# Load phase of ../BigWorkload.yml

SchemaVersion: 2018-07-01

Pool:
  QueryOptions:
    maxPoolSize: 1000
Actors:
- Name: Loader
  Type: Loader
  Threads: 10
  Database: &DB test
  CollectionCount: &CollectionCount 10000
  DocumentCount: 1e4
  BatchSize: 1000
  Document: &Doc # Documents are approximately 1 KiB in size
    t: {^RandomInt: {min: 0, max: 10}}
    w: {^RandomInt: {distribution: geometric, p: 0.1}}
    x: 0
    y: {^RandomInt: {min: 0, max: 1000}}
    z: {^RandomInt: {min: 0, max: 2147483647}}  # This is for max int for low probability of conflicts
    int0: &int {^RandomInt: {distribution: binomial, t: 200, p: 0.5}}
    int1: *int
    int2: *int
    int3: *int
    int4: *int
    int5: *int
    int6: *int
    int7: *int
    int8: *int
    int9: *int
    # Note -- genny does not support value generation within lists
    # yet. https://jira.mongodb.org/browse/TIG-1245
    intArray:
    - 1000
    - 2000
    - 3000
    - 4000
    - 5000
    - 6000
    - 7000
    - 8000
    - 9000
    string0: &string {^RandomString: {length: {^RandomInt: {min: 5, max: 15}}}}
    string1: *string
    string2: *string
    string3: *string
    string4: *string
    string5: *string
    string6: *string
    string7: *string
    string8: *string
    string9: *string
    stringShort: {^RandomString: {length: 1}}
    stringLong: {^RandomString: {length: 100}}
    compressibleStringArray:
    - &cstring AAAAAAAAAAAAAAAAAAAA
    - *cstring
    - *cstring
    - *cstring
    - *cstring
    - *cstring
    - *cstring
    - *cstring
    - *cstring
    - *cstring
    some: {embedded: {document: {with: {some: {depth: *string}}}}}
  # The Loader needs to be updated to take options to support unique, etc. I will do as a
  # follow-up. PERF-1758
  Indexes:
  - keys: {t: 1, w: 1}
  - keys: {y: 1}
  - keys: {t: 1, stringShort: 1}
  - keys: {string0: 1}
  - keys: {stringLong: 1}
    options: {unique: 1}
  - keys: {stringShort: 1, y: 1}
  - keys: {int0: 1, int1: 1, int2: 1}
  - keys: {int3: 1}
  - keys: {int4: 1}
  - keys: {int5: 1, int6: 1}
  Phases:
  - Phase: 1
    Repeat: 1
- Name: MultiCollectionUpdate
  Type: MultiCollectionUpdate
  Threads: 100
  Database: *DB
  CollectionCount: 100 # This is specifically 1% of collections
  UpdateFilter: {y: {^RandomInt: {distribution: zipfian, mean: 100}}}
  Update: {$inc: {x: 1}}
  Phases:
  - Duration: 1 hour
    # Note: total ops generated approximately 1MB oplog / second (assumes avg write is 200 bytes of oplog with 2:1 compression)
    # TBD: Is this a target or a requirement? (Is it a max or a min?)
    Rate: 10 per 1 millisecond # 10 operations on every millisecond.
- Name: MultiCollectionQuery
  Type: MultiCollectionQuery
  Threads: 100
  Database: *DB
  CollectionCount: 1000  # This is specifically 10% of collections.
  Filter: {y: {^RandomInt: {distribution: zipfian, mean: 100}}}
  Limit: 20
  Phases:
  - Duration: 1 hour
    Rate: 10 per 1 millisecond
Phases:
- Phase: 2
  Duration: 1 hour
- Type: MultiCollectionQuery
  Name: TwoMinuteQuery
  Database: *DB
  CollectionCount: *CollectionCount
  Threads: 2
  Filter: { z: { "$gt": { ^RandomInt: {min: 0, max: 2147483647} } } }
  # Documents are 1KB so we want to read 1024 documents over 2 minutes.
  Limit: 1024
  Transactions: true
  ReadConcern: Snapshot
#  MinDelay: 117 milliseconds  # Sleep between next()
#  StaggerThreadStart: 1 minute # Second thread starts after 60 seconds
#  HardLimits:
#    Next: # Note, this refers to the next() operation of a cursor
#      Latency: 500 milliseconds
#      SLA: 99.5
  Phases:
  - Phase: 3
    Duration: 24 hours
- Type: MultiCollectionQuery
  Name: TenMinuteQuery
  Database: *DB
  CollectionCount: *CollectionCount
  Threads: 2
  Sort: {z: 1}
  # Documents are 1KB so we want to read 1024 documents over 2 minutes.
  Limit: 5120
  Transactions: true
  ReadConcern: Snapshot
#  MinDelay: 117 milliseconds  # Sleep between next()
#  StaggerThreadStart: 5 minutes # Second thread starts after 60 seconds
#  HardLimits:
#    Next: # Note, this refers to the next() operation of a cursor
#      Latency: 500 milliseconds
#      SLA: 99.5
  Phases:
  - Phase: 3
    Duration: 24 hours
  - Type: MultiCollectionQuery
    Name: FullCollScan
    Database: *DB
    CollectionCount: *CollectionCount
    Threads: 1
    Transactions: true
    ReadConcern: Snapshot
#    MinDelay: 117 milliseconds  # Sleep between next()
#    StaggerThreadStart: 5 minutes # Second thread starts after 60 seconds
#    HardLimits:
#      Next: # Note, this refers to the next() operation of a cursor
#        Latency: 500 milliseconds
#        SLA: 99.5
# This actor creates and drops collections at a given rate, and optionally executes
# inserts and queries against them too.
- Type: CollectionLifeCycle
  Name: CreateAndDropCollection
  CollectionCount: 3600 # Note: This means that only after creating Collection3600 will Collection0 be dropped
  # *PerHour instead of per second to avoid small fractions.
  # TBD: What should happen if each create and drop takes 2 seconds?
  Rate: 1 per second # One drop per second and one create per second.
  Phases:
  - Phase: 4
    Duration: 24 hours
#    HardLimits:
#      Create:
#        Latency: 3 seconds
#        SLA: 99.5
#      Drop:
#        Latency: 3 seconds
#        SLA: 99.5
#      Inserts insert documents generated as defined by Document: below
- Type: RecentCollectionQuery
  Name: SingleRecordQuery
  CollectionCount: 3600
  # The first query finds a single record, high concurrency and targets the most recent collections
  Rate: 1 per 1 millisecond
  # Integer to subtract from the most recent collection nr.
  # Example: Collection3601 - 2 => Collection3599
  CollectionOffset: {^RandomInt: {distribution: geometric, p: 0.9}}
  Filter: {y: {^RandomInt: {distribution: poisson, mean: 100}}}
- Type: RecentCollectionQuery
  Name: RangeQuery
  # The second query is a range scan, lower concurrency and targets a broader set of collections
  Rate: 1 per 100 millisecond
  CollectionOffset: {^RandomInt: {distribution: geometric, p: 0.1}}
  Filter: { int3: { $gt: {^RandomInt: {distribution: poisson, mean: 100}}, $lt: "SAME RandomInt AS IN THE $gt AND ADD +1000"   }}
  Phases:
  - Phase: 4
    Duration: 24 hours
- Type: Loader
  Name: RepeatedInsert
  Document: *Doc
  # The Loader needs to be updated to take options to support unique, etc. I will do as a
  # follow-up. PERF-1758
  Indexes:
  - keys: {t: 1, w: 1}
  - keys: {y: 1}
  - keys: {t: 1, stringShort: 1}
  - keys: {string0: 1}
  - keys: {stringLong: 1}
    options: {unique: 1}
  - keys: {stringShort: 1, y: 1}
  - keys: {int0: 1, int1: 1, int2: 1}
  - keys: {int3: 1}
  - keys: {int4: 1}
  - keys: {int5: 1, int6: 1}
  Phases:
  - Phase: 4
    Duration: 24 hours

    # TBD
    #     truncate:
    #          record_count: 1000
    #          period: 1 sec
    #
    # Is this satisfied by deploying a replica set?
    #    An oplog that is being tailed
    #    ... including oplog tailing